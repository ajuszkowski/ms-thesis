\chapter{Implementation}
\label{section:impl}

This chapter describes the architecture of the tool \texttt{mousquitaires} ...

language: java


\section{Program Requirements}
\label{section:impl:requirements}

- stability (tests)

- scalability (new features of language, new models, new tasks for a program )

- transparency

- efficiency

\section{Program Components}
\label{section:impl:comp}
Big view

\section{C11 to YTree parser}
\label{section:impl:ytree}

below: mostly mock text.

- The language-dependent syntax tree:
        - for now it's the C subset language which I called 'Cmin'; as a base, I used the C11 grammar from ANTLR github repository, then I simplified it a lot, cutting off many unnecessary C syntax features and making it more convenient for parsing. When developing the Cmin language, I kept in mind C elements that are necessary for processing the linux kernel code, though for now not the whole grammar element described in file 'Cmin.g4' are being implemented;
        - later I am going to add the litmus grammar as well;
        - in future, it will be not a problem to add any new C-like language;

- The language-independent abstract syntax tree (aliased 'Ytree', where 'Y' resembles branching of the tree):
        - all tree nodes in my code are prefixed with 'Y', see tentative (yet almost complete) class hierarchy in picture 'YEntity.png';
        - this AST contains very basic language elements according to the C execution model (statements and expressions);
        - converting the language-dependent syntax tree to the language-independent syntax tree is performed by Visitor pattern (e.g., for Cmin->Ytree conversion is made by 'CminToYtreeConverterVisitor')
        - minor changes are performed by converting to ytree representation: desugaring the target code, etc.


\section{YTree to XGraph event converter}
\label{section:impl:comp:xgraph}

- Then, the AST is being interpreted and converted to event-based representation (aliased 'Xrepr' for eXecution representation):
        - more low-level code representation (or high-level assembly);
        - I try to keep this representation close to the one you described in your papers: basic load \& store events, branching events, fence events;
        - this representation is being implementing these days, I've just started doing it (see current class hierarchy in the picture 'XEntity.png');
        
- After we acquired the event-based representation, we can perform some modifications/simplifications/optimisations on it (separately, allowing user to manage them):
        - converting to SSA form as one of necessary steps before encoding;
        - (more? -- I'm not thinking about it yet);
        
\subsection{Loop unrolling}
The original program encoded into the \texttt{XGraph} represents a \textit{flow graph}, a connected cyclic directed graph with single source node \texttt{[ENTRY]} (usually for convenience all leaves are connected to the sink node \texttt{[EXIT]}). The cycles are caused by low-level jump instructions, obtained from non-linear high-level control-flow statements (such as \texttt{while}, \texttt{do-while}, \texttt{for}, etc.). However, the cyclic flow graph cannot be encoded into SMT formula since ...
//TODO:REFERENCE.%TODO

Although there are multiple techniques for converting cyclic directed graphs into DAGs (Directed Acyclic Graphs), most of them are either not applicable to the problem of encoding graph into SMT formula, or work only for special cases (e.g., only for single-nested loops).
// TODO: examples%TODO

In the work~\cite{Porthos17}, the authors propose using the \textit{loop unrolling} technique to solve this problem, however the loops in flow graph are restricted syntactically by using only \texttt{while} statement without loop-breaking statements. The general case (that uses jumps to arbitrary instructions, which may be produced by \texttt{C} instruction \texttt{goto}) requires more thorough control-flow analysis.
%The following paragraphs will explain in the details of unrolling algorithm used in current work.

\subsubsection{Identifying the loops}

In order define the unrolling algorithm, we need to introduce some graph-theoretical terminology used in compiler theory.
All edges of a flow graph may be divided into three categories: \textit{advancing edges} that go from a node to its proper descendant in the tree constructed by the depth-first traverse starting at the source node; \textit{retreating edges} that go from a node to its ancestor in the tree, and \textit{cross edges} (edges that lead from a node to another node that is neither its descendant nor ancestor)~\cite{aho2007compilers::loop_unrolling}.
%The node \textit{n} of a flow graph \textit{dominates} the node \textit{d} iff every path from the entry node of the flow graph to \textit{n} goes through \textit{d}.
In a control flow graph, branching statements (\texttt{if-then-else}, \texttt{switch}) introduce cross edges in the graph, while other control flow statements (\texttt{while}, \texttt{do-while}, \texttt{for}, \texttt{continue}, \texttt{break}, \texttt{goto}, etc.) introduce retreating edges.

If the head of retreating edge dominates its tail (i.e., \textit{every} path from head to tail goes through head), such edge is called \textit{back edge}. If all retreating edges of a flow graph are back edges, such graph is called \textit{reducible} (otherwise \textit{irreducible}). As it was noted in ~\cite{aho2007compilers::loop_unrolling}, the flow graphs that does not use jumps to arbitrary instructions are reducible. However, it is not hard to transform the irreducible graph to the reducible equivalent by cloning the node incident to two back edges to two nodes as it is shown in Figure~\ref{fig:irr-to-r}. Therefore, the loop unrolling algorithm can assume that the flow graph is reducible.
%All edges of a flow graph may be divided into four categories: \textit{tree edges} (edges of the tree constructed by the depth-first traverse starting at the source node), \textit{forward edges} (edges that lead from a node to its proper descendant that is not a tree edge), \textit{back edges} (edges that lead from a node to its ancestor), and \textit{cross edges} (edges that lead from a node to another node that is neither its descendant nor ancestor)~\cite{Dasgupta:2006:ALG:1177299::dfs}. Obviously, every back edge forms the loop in the flow graph -- the path ending in its start node, that can be represented as set of nodes forming this path. 

% todo: move Aho's chapters names to the name of reference

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[draw=none] (invis) {};
\node[c] (1) [above=0.5cm of invis] {$1$};
\node[c] (2) [below left of=invis] {$2$};
\node[c] (3) [below right of=invis] {$3$};
\path[->]
(1) edge [bend right=10] node {} (2)
(1) edge [bend left=10] node {} (3)
(2) edge [bend left=15] node {} (3)
(3) edge [bend left=15] node {} (2)
;

\node[draw=none] (invis) [right=3cm of invis] {$\longmapsto$};

\node[draw=none] (invis) [right=3cm of invis] {};
\node[c] (1) [above=0.5cm of invis] {$1$};
\node[c] (2) [below left of=invis] {$2$};
\node[c] (3) [below right of=invis] {$3$};
\node[c] (2') [right=1.5cm of 3] {$2'$};
\path[->]
(1) edge [bend right=10] node {} (2)
(1) edge [bend left=10] node {} (3)
(2) edge [bend right=10] node {} (3)
(3) edge [bend left=15] node {} (2')
(2') edge [bend left=15] node {} (3)
;
\end{tikzpicture}
\caption{Transforming irreducible flow graph into reducible graph~\cite{aho2007compilers::handling_irreducible}} \label{fig:irr-to-r}
\end{figure}

The \textit{loop} (or \textit{natural loop}) in a program is the set of nodes that form a path in a flow graph with a single single-entry node (\textit{loop head}) which dominates all other loop nodes, and single back edge that goes to the head. The more precise definition of loop allows merging some cycles, caused by the set of back edges $E_i = \{(v_i, w_i) \ | \ (v_i, w_i) \in G.E \land w_i = h \}$ that point to the same head and having non mutually-nested set of nodes, into single loop:

%The loop in a program is the set of nodes reachable in the reversed graph from the origin of the back edge in the original flow graph.

\begin{definition}
The \textit{loop} in a flow graph $G = (V, E)$ caused by some set of back edges $E_i \subset G.E$ is the tuple $l_i = (h, N, T, R)$ where
\begin{itemize}
\item the loop \textit{head} $h \in G.N$,
\item the set of \textit{loop nodes} $N = \{ u \ | \ u$ is reachable in reversed graph $G^{-1}$ from origins of back edges $\{w \ | \ (w, h) \in E_i\}$ such that the reachability search does not go through the loop head $h \}$,
\item the set of \textit{tails} of the loop $T \subseteq G.N$ such that $T = \{w \ | \ (w, h) \in G.E\}$
\item the set of \textit{reference nodes} $R \subseteq G.N$ such that $R = \{(u,v) \ | \ u \in l_i.N \land v~\notin~l_i.N\}$
\end{itemize}

\end{definition}

This constructive definition of the loop directly leads to the loop searching algorithm~\cite{aho2007compilers::loop_unrolling}:

\begin{algorithm}
\caption{Algorithm for finding loops in the flow graph}\label{alg:find-loops}
\algorithmicrequire{The flow graph $G$ with the source node $v_s$}
\algorithmicensure{Set $Loops$ of discovered loops $loop = (h, T, R, N)$ where $h$ is the head of loop, $T$ is the set of tails of the loop, $N$ is the set of all nodes of the loop, $R=\{(u,v)| u \in N \land v \notin N \}$ is the set of edges (references) outside the loop}
\begin{algorithmic}[1]
\Function{FindLoops}{G}
\State $E_b \gets$ all back edges of the graph $G$
\ForAll {back edge $(v_i, h_i) \in E_b$}
  \State mark the head $h_i$ as visited \Comment{do not go outside the loop head}
  \ForAll {edge $(u, w^{-1}) \in G^{-1}.E$ explored while traversing the reversed graph $G^{-1}$ in depth-first order starting from node $v_i$}
    \State remember visited node $u$ in the set $N_i$
    \State $merged \gets false$
    \ForAll {already collected loop $l \in Loops$}
      \If {$(l.h = h_i) \land (l.N \setminus N_i \neq \emptyset \land N_i \setminus l.N \neq \emptyset)$} 
        \newline \Comment{merge these two loops into one:}
        \State $l.N \gets l.N \cup N_i$ \label{alg:find-loops:merge-loops-1}
        \State $l.T \gets l.T \cup T_i$ \label{alg:find-loops:merge-loops-2}
        \State $merged \gets true$
        \State \textbf{break}
      \EndIf
    \EndFor
     \If {not $merged$}
        \State add $l_i = (h_i, T_i, R_i, N_i)$ to $Loops$
      \EndIf
  \EndFor
  \newline \Comment{fill in the set $l_i.R$ of references outside the loop:}
  \ForAll {loop node $v \in l_i.N$}
    \ForAll {edge $(v, w) \in G.E$}
      \If {$w \notin l_i.N$}
        \State add $v$ to the set $l_i.R$ of references outside the loop
      \EndIf
    \EndFor
  \EndFor
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

Examples of possible mutual arrangements of two nested loops in a flow graph are shown in Figure~\ref{fig:nested-loops} (the back edges are pictured with dotted lines). In the first example~\ref{fig:nested-loops-1}, the loop $l_{2 \rightarrow 3}$ caused by back edge $2 \rightarrow 3$ has the set of nodes $\{2, 3\}$, while the loop $l_{4 \rightarrow 1}$ has the set of nodes $\{1,2,3,4\}$, which is a superset of the set of nodes of $l_{2 \rightarrow 3}$, therefore the latter loop is the outer loop of the former one, and it should be unrolled firstly. The same reasoning applies to all other examples~\ref{fig:nested-loops-2} -- \ref{fig:nested-loops-4}.

Figure~\ref{fig:merged-loop} illustrates two cycles $1\rightarrow2\rightarrow3$ and $1\rightarrow2\rightarrow4$ with the same head $1$ that can be safely merged into one loop $\{1,2,3,4\}$ with head $1$ (lines~\ref{alg:find-loops:merge-loops-1} and~\ref{alg:find-loops:merge-loops-2} of Algorithm~\ref{alg:find-loops}) and interpreted as a single loop with branching expression at the head node.

\begin{figure}
\centering
\begin{subfigure}{0.18\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below of=1] {$2$};
\node[c] (3) [below of=2] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [] node {} (3)
(3) edge [] node {} (4)
(3) edge [bend left=40,dotted] node {} (2)
(4) edge [bend left=50,dotted] node {} (1)
;
\end{tikzpicture}
\caption{} \label{fig:nested-loops-1}
\end{subfigure}
\hspace*{\fill}
\begin{subfigure}{0.18\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below of=1] {$2$};
\node[c] (3) [below of=2] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [] node {} (3)
(3) edge [] node {} (4)
(3) edge [bend right=50,dotted] node {} (1)
(4) edge [bend left=50,dotted] node {} (1)
;
\end{tikzpicture}
\caption{} \label{fig:nested-loops-2}
\end{subfigure}
\hspace*{\fill}
\begin{subfigure}{0.18\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below of=1] {$2$};
\node[c] (3) [below of=2] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=40,dotted] node {} (2)
(4) edge [bend left=50,dotted] node {} (1)
;
\end{tikzpicture}
\caption{} \label{fig:nested-loops-3}
\end{subfigure}
\hspace*{\fill}
\begin{subfigure}{0.18\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below of=1] {$2$};
\node[c] (3) [below of=2] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=40,dotted] node {} (2)
(3) edge [bend left=40,dotted] node {} (1)
;
\end{tikzpicture}
\caption{} \label{fig:nested-loops-4}
\end{subfigure}
\hspace*{\fill}
\begin{subfigure}{0.18\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below of=1] {$2$};
\node[c] (3) [below of=2] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [] node {} (3)
(3) edge [] node {} (4)
(2) edge [bend left=40,dotted] node {} (1)
(3) edge [bend left=40,dotted] node {} (2)
(4) edge [bend left=40,dotted] node {} (3)
;
\end{tikzpicture}
\caption{} \label{fig:nested-loops-5}
\end{subfigure}
\caption{Examples of possible mutual arrangements of two nested loops in a flow graph} \label{fig:nested-loops}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below left of=1] {$2$};
\node[c] (3) [below right of=1] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [bend left=50,dotted] node {} (1)

(1) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=80,dotted] node {} (1)
;
\end{tikzpicture}
\caption{Example of flow graph with multiple cycles merged into a single loop} \label{fig:merged-loop}
\end{figure}

\subsubsection{Binding unrolled loops}

Once the set of loops of the flow graph is defined, they need to be unrolled and bounded into single graph. Unrolling is being performed up to the user-defined bound $k$, this means every loop is being unwound to the acyclic subgraph of size at most $k$. This bound is defined separately for each collected loop, so that the $l$-nested loop has at most $k^l$ nodes. Note that the loop unrolling does not require any data-flow information: the reachability analysis of a particular node in the unrolled graph will be performed later by the SMT solver. This is rather rough underapproximation, which is to be handled by user by specifying the unrolling bound $k$.

The algorithm for unrolling and binding nested loops is as following:

\begin{algorithm}
\caption{Algorithm for unrolling and binding nested loops}\label{alg:bind-loops}
\algorithmicrequire{The ordered list $Loops$ of nested loops $l_i$ such that $l_1.N \subset l_2.N \subset ... l_t.N$}
\algorithmicensure{Set $Loops$ of discovered loops $loop = (h, N)$ where $d$ is the head of loop, $L$ is the set of nodes of the loop}
\begin{algorithmic}[1]
\Function{UnrollAndBindLoops}{$Loops$}
\State //to be done
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{figure}1
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below left of=1] {$2$};
\node[c] (3) [below right of=1] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [bend left=50,dotted] node {} (1)
(1) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=80,dotted] node {} (1)
;
\node[draw=none] (impl) [right=3cm of 3] {$\overset{k = 6}{\longmapsto}$};
;
\node[c] (21) [right=3cm of impl] {$2_1$};
\node[c] (11) [above right=1cm and 1cm of 21]{$1_1$};
\node[c] (31) [below right=1cm and 1cm of 11] {$3_1$};
\node[c] (41) [below of=31] {$4_1$};
\node[c] (12) [below of=21] {$1_2$};
\node[c] (22) [below left=1cm and 1cm of 12] {$2_2$};
\node[c] (32) [below right=1cm and 1cm of 12] {$3_2$};
\node[c] (13) [below of=41] {$1_3$};
\node[c] (14) [below of=22] {$1_4$};
\node[c] (43) [below of=32] {$4_3$};
\node[c] (23) [below of=13] {$2_3$};
\node[c] (33) [below of=13] {$3_3$};
\node[c] (24) [below left=1cm and 1cm of 14] {$2_4$};
\node[c] (34) [below right=1cm and 1cm of 14] {$3_4$};
\node[c] (15) [below right=1cm and -0.3cm of 43] {$1_5$};
\node[c] (44) [below of=33] {$4_4$};
\node[c] (6) [below left=1cm and 1cm of 15] {$6$};
\node[] (11k) [right=3.2cm of 11] {$(k = 1)$};
\node[] (31k) [right=1.7cm of 31] {$(k = 2)$};
\node[] (41k) [right=1.7cm of 41] {$(k = 3)$};
\node[] (13k) [right=1.7cm of 13] {$(k = 4)$};
\node[] (33k) [right=1.7cm of 33] {$(k = 5)$};
\node[] (44k) [right=1.7cm of 44] {$(k = 6)$};
\path[->]
(11) edge [] node {} (21)
(11) edge [] node {} (31)
(31) edge [] node {} (41)
(21) edge [] node {} (12)
(12) edge [bend right=10] node {} (22)
(12) edge [bend left=10] node {} (32)
(41) edge [] node {} (13)
(22) edge [] node {} (14)
(32) edge [] node {} (43)
(13) edge [] node {} (23)
(13) edge [] node {} (33)
(14) edge [bend right=10] node {} (24)
(14) edge [bend left=10] node {} (34)
(43) edge [] node {} (15)
(33) edge [bend right=10] node {} (15)
(33) edge [bend left=10] node {} (44)
(24) edge [bend right=20] node {} (6)
(34) edge [] node {} (6)
(15) edge [] node {} (6)
(44) edge [bend left=20] node {} (6)
;
\end{tikzpicture}
\label{fig:loop-unwind}
\caption{Example of the flow graph from the Figure~\ref{fig:merged-loop}, unwinded up to the bound $k = 6$} 
\end{figure}


\section{XGraph to ZFormula (SMT) encoder}
\label{section:impl:comp:zformula}

- Then, this modified event-representation is being encoded to SMT formula and sent to the solver.



\section{Optimisations}

... performed on each stage