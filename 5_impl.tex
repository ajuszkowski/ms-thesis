\chapter{\nohyphens{The~\mousquetaires:~implementation}}
\label{ch:impl}

% function invocations/calls: inlining with binding
% contexts: for now, no ctxs
% comparing to cprover (https://www.cprover.org/cbmc/doc/manual.pdf, page 45, absatz about 'goto') where "the loop is unwound a given number of times" , we SHOULD have 2 modes of unrolling: 1) number of times, and 2) number of high-level instructions executed
% TODO(code): (https://www.cprover.org/cbmc/doc/manual.pdf, page 45) "The break and continue statements are replaced by equivalent goto statements as described in the ANSI-C standard."

% TODO: arrays: cprover manual page 48

This Chapter describes the architecture of the \mousquetaires framework.

The programming language choice for \mousquetaires was made in favour of java in order to reuse some parts of its predecessor \Porthos that was written in java. However this language does not show best results in performance benchmarks (comparing to, for example, C++)~\cite{TODO}, the performance cornerstone of \mousquetaires (as well as any other SMT-based code analyser) is the phase of solving the SMT-formula, which is left to the third-party SMT-solver called from \mousquetaires via java API. However, considering the perspective of using \mousquetaires as a static analyser for real-world programs, we also must to take into account memory problems at both encoding and solving stages. 

\section{Requirements}
\label{ch:impl:requirements}

The main reason for starting the work on re-implementing the \Porthos tool was the need to extend input language to be able to process real C programs in perspective. The existing \Porthos architecture mixes high-level recursive \textit{instructions} (statements of C) with low-level non-recursive \textit{events}, to which the high-level instructions are compiled (see classes of package `\texttt{dartagnan.program}' in the \Porthos project~\footnote{Project web site: \url{http://github.com/hernanponcedeleon/PORTHOS}}). Both instructions and events are then encoded into the SMT-formula. However, this approach is poorly extensible as to adding support for a high-level control-flow instruction (say, the \texttt{do-while} loop in C) requires making changes in many places of code from parser to encoder. Moreover, we encounter serious problems when we need to add support for control-flow jumps (as \texttt{continue}, \texttt{break}, \texttt{goto} in C).

Therefore, while planning the architecture of \mousquetaires, we decided to clearly separate high-level recursive code representation as Abstract Syntax Tree (AST) and low-level compiled event-based representation as a flow-graph. Such a modular architecture allows to use multiple input-language parsers and convert parsed syntax trees to our AST, thus having support for multiple languages (for instance, the original input language of \Porthos tool, two syntaxes of litmus tests used by \tool{herd}, and even assembly language for any supported architecture).

The target \textbf{requirements} for the new tool was set up as following (in descending order of priority):

\begin{enumerate}[nolistsep]
        \item stability and transparency (KISS principle)
                \begin{itemize}
                        \item choice in favour of simplicity and readability at every step;
                        \item using software design patterns if necessary;
                        \item using immutable data structures for intermediate representations;
                        \item high code coverage by unit and functional tests;
                \end{itemize}                
        \item efficiency
                \begin{itemize}
                        %\item usage of time- and memory-optimised data structures;
                        \item keeping trade-off between execution time and memory consumption;
                \end{itemize}
        \item extensibility
                \begin{itemize}
                        \item clear modular architecture
                \end{itemize}
\end{enumerate}

\section{Program Components}
\label{ch:impl:comp}

Generally, \mousquetaires uses following  ...

\section{Parsing the input language as YTree}
\label{ch:impl:ytree}

below: mostly mock text.

- The language-dependent syntax tree:
        - for now it's the C subset language which I called 'Cmin'; as a base, I used the C11 grammar from ANTLR github repository, then I simplified it a lot, cutting off many unnecessary C syntax features and making it more convenient for parsing. When developing the Cmin language, I kept in mind C elements that are necessary for processing the linux kernel code, though for now not the whole grammar element described in file 'Cmin.g4' are being implemented;
        - later I am going to add the litmus grammar as well;
        - in future, it will be not a problem to add any new C-like language;

- The language-independent abstract syntax tree (aliased 'Ytree', where 'Y' resembles branching of the tree):
        - all tree nodes in my code are prefixed with 'Y', see tentative (yet almost complete) class hierarchy in picture 'YEntity.png';
        - this AST contains very basic language elements according to the C execution model (statements and expressions);
        - converting the language-dependent syntax tree to the language-independent syntax tree is performed by Visitor pattern (e.g., for Cmin->Ytree conversion is made by 'CminToYtreeConverterVisitor')
        - minor changes are performed by converting to ytree representation: desugaring the target code, etc.


\section{YTree to XGraph event converter}
\label{ch:impl:x2y}

- Then, the AST is being interpreted and converted to event-based representation (aliased 'Xrepr' for eXecution representation):
        - more low-level code representation (or high-level assembly);
        - I try to keep this representation close to the one you described in your papers: basic load \& store events, branching events, fence events;
        - this representation is being implementing these days, I've just started doing it (see current class hierarchy in the picture 'XEntity.png');
        
- After we acquired the event-based representation, we can perform some modifications/simplifications/optimisations on it (separately, allowing user to manage them):
        - converting to SSA form as one of necessary steps before encoding;
        - (more? -- I'm not thinking about it yet);
        
\subsection{Loop unrolling}
\label{ch:impl:x2y:unrolling}
% If the analysing program contains a loop, then its control-flow graph represents the cyclic directed graph. Although, in order to be able to encode such a cyclic structure as a boolean formula, this graph needs to be  
% In order to be

The original program encoded into the \texttt{XGraph} represents a \textit{flow graph}, a connected cyclic directed graph with single source node \texttt{(ENTRY)} (usually for convenience all leaves are connected to the sink node \texttt{(EXIT)}). The cycles are caused by low-level jump instructions, obtained from non-linear high-level control-flow statements (such as \texttt{while}, \texttt{do-while}, \texttt{for}, etc.). However, the cyclic flow graph cannot be encoded into SMT formula since ...
//TODO:REFERENCE.%TODO



\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below left of=1] {$2$};
\node[c] (3) [below right of=1] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [bend left=50,dotted] node {} (1)
(1) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=80,dotted] node {} (1)
;
\node[draw=none] (impl) [right=3cm of 3] {$\overset{k = 6}{\longmapsto}$};
;
\node[c] (21) [right=3cm of impl] {$2_1$};
\node[c] (11) [above right=1cm and 1cm of 21]{$1_1$};
\node[c] (31) [below right=1cm and 1cm of 11] {$3_1$};
\node[c] (41) [below of=31] {$4_1$};
\node[c] (12) [below of=21] {$1_2$};
\node[c] (22) [below left=1cm and 1cm of 12] {$2_2$};
\node[c] (32) [below right=1cm and 1cm of 12] {$3_2$};
\node[c] (13) [below of=41] {$1_3$};
\node[c] (14) [below of=22] {$1_4$};
\node[c] (43) [below of=32] {$4_3$};
\node[c] (23) [below of=13] {$2_3$};
\node[c] (33) [below of=13] {$3_3$};
\node[c] (24) [below left=1cm and 1cm of 14] {$2_4$};
\node[c] (34) [below right=1cm and 1cm of 14] {$3_4$};
\node[c] (15) [below right=1cm and -0.3cm of 43] {$1_5$};
\node[c] (44) [below of=33] {$4_4$};
\node[c] (6) [below left=1cm and 1cm of 15] {$6$};
\node[] (11k) [right=3.2cm of 11] {$(k = 1)$};
\node[] (31k) [right=1.7cm of 31] {$(k = 2)$};
\node[] (41k) [right=1.7cm of 41] {$(k = 3)$};
\node[] (13k) [right=1.7cm of 13] {$(k = 4)$};
\node[] (33k) [right=1.7cm of 33] {$(k = 5)$};
\node[] (44k) [right=1.7cm of 44] {$(k = 6)$};
\path[->]
(11) edge [] node {} (21)
(11) edge [] node {} (31)
(31) edge [] node {} (41)
(21) edge [] node {} (12)
(12) edge [bend right=10] node {} (22)
(12) edge [bend left=10] node {} (32)
(41) edge [] node {} (13)
(22) edge [] node {} (14)
(32) edge [] node {} (43)
(13) edge [] node {} (23)
(13) edge [] node {} (33)
(14) edge [bend right=10] node {} (24)
(14) edge [bend left=10] node {} (34)
(43) edge [] node {} (15)
(33) edge [bend right=10] node {} (15)
(33) edge [bend left=10] node {} (44)
(24) edge [bend right=20] node {} (6)
(34) edge [] node {} (6)
(15) edge [] node {} (6)
(44) edge [bend left=20] node {} (6)
;
\end{tikzpicture}
\label{fig:loop-unwind}
\caption{Example of the flow graph from Figure~\ref{fig:merged-loop.....}, unwinded up to the bound $k = 6$}
\end{figure}


\section{XGraph to ZFormula (SMT) encoder}
\label{ch:impl:comp:zformula}

- Then, this modified event-representation is being encoded to SMT formula and sent to the solver.



% say something about equals() and hashCode()



\section{Optimisations}

... performed on each stage