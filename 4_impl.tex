\chapter{PorthosC: The implementation}
\label{ch:impl}

The main call for commencing the work on \porthos[2] was the need for processing real-world C programs, which, at first, requires the input language to be extended.
This implies the support not only for new syntactic structures of the C language (such as the \texttt{switch} statement or the postfix increment operator \texttt{i++}), but also for its fundamental concepts and features (such as types, pointer arithmetic or first-order functions), which requires revision of the whole architecture of the tool.
Yet far from all the C language is supported (which, considering its complexity and numerous pitfalls, goes far beyond current thesis%
%
\footnote{To ensure this, one merely has to look at existing C compiler implementations, for instance, the open-source \tool{gcc} compiler, which uses the C parser written in more than 18.5 thousand lines of code (see \url{https://github.com/gcc-mirror/gcc/blob/master/gcc/c/c-parser.c})}%
%
), we consider the accomplished work as a step towards it.


\section{General principles}
\label{ch:impl:principles}

The \porthos[1] does not distinguish the event-based program model from the high-level AST, and they both are encoded into a single SMT-formula (see classes of package `\texttt{dartagnan.program}' of \porthos[1]).
Moreover, the syntax tree is implemented in \porthos[1] as a mutable data structure, which is being modified at all stages of the program (for instance, see the methods `\texttt{dartagnan.program.Program.compile(...)}' of \porthos[1] that recursively compute some properties of the AST and change its state).
We are inclined to consider the old architecture to be fast to develop, but difficult to maintain (since it is difficult to guarantee the correctness of the program) and extend (since adding the support for a new high-level instruction requires changing multiple components of the program, from parser to encoder).

Therefore, while working on the new design of \porthos[2], we clearly separated the high-level intermediate code representation (the AST structure) from the low-level event-based representation (the event-flow graph).
Such a modular architecture will allow to support multiple input languages%
%
\footnote{Apart from the C language, \porthos[2] should be able to analyse litmus tests in different assembly languages and, as a compatibility mode, the input language of \porthos[1].} %
%
by parsing them and converting parsed syntax trees to a simplified AST.

All data-transfer objects~(DTOs) used by \porthos[2] must be immutable, so that it is possible to guarantee the correctness of the program by controlling preservation of its invariants.
The immutability in \porthos[2] is implemented via \texttt{final} fields that are assigned by the immutable-object values (either a primitive type, or another user-defined immutable object, or an immutable collection provided by the library Guava by Google%
%
\footnote{The Guava project repository: \url{https://github.com/google/guava/}}%
%
).

During the development of \porthos[2], we mainly followed the \textit{KISS~principle}, which can be exhaustively described in 17 Unix Rules of Eric Raymond~\cite{raymond2003art}.
The following list summarises the main rules we followed during the development of \porthos[2]:

\vspace{0.5em}
\begin{enumerate}[nolistsep]
  \item \textit{Robustness:}
    \begin{enumerate}[label*=\arabic*.]
      \item completeness of the analysis,
      \item modular architecture: each module can be tested independently,
      \item usage of software design patterns where necessary, and
      \item usage of immutable data structures for all DTOs.
    \end{enumerate}
  \item \textit{Transparency:}
    \begin{enumerate}[label*=\arabic*.]
      \item following the principles of simplicity and readability,
      \item clear and informative program output, and
      \item following the clear code style.
    \end{enumerate}
  \item \textit{Efficiency:}
    \begin{enumerate}[label*=\arabic*.]%[leftmargin=1.5em]
      \item keeping the trade-off between execution time and memory usage.
    \end{enumerate}
  \item \textit{Extensibility:}
    \begin{enumerate}[label*=\arabic*.]%[leftmargin=1em]
      \item clear modular architecture.
    \end{enumerate}
\end{enumerate}

Robustness of the analysis is the main criterion of \porthos[2] as a verification tool.
Although it makes the analysis more sensitive to the combinatorial explosion, it preserves the completeness of analysis, which is necessary for a model-checking tool.
As a robust and transparent tool, \porthos[2] must adhere to the strategy of aborting its work on any unexpected outcome (for instance, if a parser failed to parse the string and the recovery algorithm is not described).
One of the transparency principles is following the clear code style.
This mainly means the clear and informative naming of classes, functions and fields.
It also implies the unified ordering of methods in classes, minimised size of methods code, clear tabulation, etc.

As its predecessor, \porthos[2] uses the open-source SMT-solver \tool{Z3}%
%
\footnote{The \tool{Z3} project repository: \url{https://github.com/Z3Prover/z3}} %
%
by Microsoft Research~\cite{de2008z3}. However, unlike its predecessor, \porthos[2] has an additional abstraction level, \zformula{} (see Section~\ref{ch:impl:model:zformula}), that allows the use any other SMT-solver.

As its predecessor, \porthos[2] is written in \textit{Java}, firstly, in order to be able to reuse some parts and concepts of \porthos{} also written in Java, and secondly, because the authors find the concepts of Object-Oriented Programming~(OOP) inherent in Java suitable for modelling the programming languages.
Although Java does not show the best results in performance benchmarks (for example, compared to C++~\cite{hundt2011loop}), the performance cornerstone of \porthos[2] (as well as any other SMT-based code analyser) is the phase of solving the SMT-formula, which is left to the third-party SMT-solver invoked by \porthos[2] via a Java API.
However, considering the perspective of using \porthos[2] as a static analyser for real-world programs, the memory optimisation problem must also be taken into account during both encoding and solving stages.
It is worth noting that, for the reasons of simplicity, \porthos[2] is not a concurrent program, however, we believe that due to its modular architecture it can be easily parallelised on the level of program modules.

Currently, \porthos[2] can operate only in the intra-procedural analysis mode (not supporting invocations of the user-defined functions), assuming that each function defined in the input file is being executed in a separate thread.
However, the redesigned architecture of \porthos[2] can be easily extended to support the inter-procedural (cross-function) analysis by inlining user-defined functions calls and binding variable contexts.
In this mode, instead of analysing a single source code file, the tool can process the whole code project, where the functions to be executed in parallel are specified separately by the user.
Also, the tool can be extended to detect the concurrent parts of the code automatically at the pre-compilation stage.
For that, the pre-compiler should recognise functions that commence a new process (such as \texttt{pthread\_create} from \texttt{pthread.h}) and resolve the argument that points to the thread function.
This functionality is left beyond current thesis.


\section{Program input}
\label{ch:impl:input}

Both \porthos[1] and \porthos[2] use the \tool{ANTLR} parser generator%
%
\footnote{The \tool{ANTLR} project repository: \url{https://github.com/antlr/antlr4}}%
%
~\cite{parr2013definitive} for creating the input-language parsers.
The \tool{ANTLR} takes as input the user-defined grammar of the target language in a BNF-like form and produces the LL(*)-parser and optionally some auxiliary classes (such as listeners and visitors for the syntax tree).
Although this parser may not be as efficient as a hand-written language-optimised parser, it reduces the overhead of implementing the parser significantly.
Among other advantages \tool{ANTLR}, it has a rather large collection of officially supported grammars.
Nonetheless, the intuitive syntax for defining grammars and numerous of tools for debugging grammars make the \tool{ANTLR} an attractive instrument for processing languages.

\begin{figure}[t]%[!h]%[!hb]
\centering
%basicstyle=\ttfamily\tiny,
\begin{lstlisting}[basicstyle=\rmfamily\scriptsize,%
  %alsoletter={:,|,;,(,)},
  %morekeywords={:,|,;,(,)},
  %keywordstyle=\color{dkblue},
  literate=%
  {<}{{$\langle$}}1
  {>}{{$\rangle$}}1,
  escapeinside={[*}{*]},]
<program>
      :      <initialisation>   <thread>+   <assertion>
      ;
<thread>
      :      thread   <thread-id>   <instruction>
      ;
<instruction>
      :      <atom>
      |      `{'   <instruction>   `}'
      |      <instruction>   `;'   <instruction>
      |      `while'   `('   <bool-expr>   `)'   <instruction>
      |      `if'   <bool-expr>   `{'   <instruction>   `}'   <instruction>
      ;
<atom>   
      :      <register>   `[*<*]-'   <expression>
      |      <register>   `[*<*]:-'   <location>
      |      <location>   `:='   <register>
      |      <register>   `='   <location>   `.'   `load'    `('   <atomic>   `)'
      |      <location>   `='   <register>   `.'   `store'   `('   <atomic>   `)'
      |      (`mfence'   |   `sync'   |   `lwsync'   |   `isync')
      ;
<bool-expr>
      :      `true'
      |      `false'
      |      <expression>   (`and'   |   `or')   <expression>
      |      <expression>   (`=='   |   `!='   |   `>'   |   `>='   |   `[*<*]'   |   `[*>*]=')   <expression>
      ;
<expression>
      :      [0-9]
      |      <register>
      |      <expression>   (`*'   |   `+'   |   `-'   |   `/'   |   `%')   <expression>
      ;
\end{lstlisting}
\caption{Sketch of the input language grammar used by \oldporthos{}}
\label{fig:in_grammar_pts}
\end{figure}

Figure~\ref{fig:in_grammar_pts} represents the grammar sketch in BNF syntax of the input language used by \porthos[1].
The input language parser used by \oldporthos{} suffers from several disadvantages.
Firstly, it contains the parser code inlined directly into the grammar, so that the grammar serves as a template for the parser code (which is called semantic actions in \tool{ANTLR}).
Such a combining of two expressive languages makes the code hardly understandable and, therefore, poorly maintainable.
In \porthos[2], we clearly separated the parser (generated from the grammar file `\textit{<grammar>.g4}') from converting the \tool{ANTLR} syntax tree to the AST, that is one for all languages of an input program.

Secondly, \porthos{} resolves the semantics of operations syntactically (it was defined in the \tool{ANTLR} grammar), whereas it should be resolved by a separate module operating on the AST level%
%
%TODO: check or remove this
%\footnote{Most modern languages (including C++) allow the function overloading, thus requiring the type information to be available for the function resolution algorithm (see Section~\ref{ch:impl:proc:x-pre-compiler}).}%
%
, so that it does not require to change grammar for encoding the semantics of a new function. %adding support for a new function.
%\footnote{for instance, given two functions `\lstinline{foo(int a)}' and `\lstinline{foo(char a)}' compiled by a C++ compiler, the code `\lstinline{int a = '1'; foo(a);}' will invoke the first method rather than the second one.}.%
As the reader might have noticed from the grammar sketch in Figure~\ref{fig:in_grammar_pts}, different kinds of memory operations of of the \oldporthos{} input language vary syntactically as well.
For example, the assignment of a local computation to a register uses the symbol `\lstinline{<-}', the atomic non-relaxed load operation is denoted by \lstinline{<:-}', atomic non-relaxed store operation is denoted by `\lstinline{:=}', and the semantics of relaxed \lstinline{load} and \lstinline{store} is resolved syntactically by matching the function name and arguments.
Moreover, only the operator `\lstinline{<-}' accepts an expression as the source of data, which means that expressions could be assigned only to registers.
In \porthos[2], the semantics of the data-flow operation is determined according to the types of operands, that are determined during the pre-compilation stage (see Section~\ref{ch:impl:proc:x-pre-compiler}).
The semantics of the functions also being resolved during the compilation stage via the \textit{invocation hooking} mechanism (see Section~\ref{ch:impl:proc:x-compiler}).

Thirdly, the grammar used by \oldporthos{} accepts only a restricted set of operations.
For example, the computation expressions can use only local variables.
Thus, in the assignment expression `\lstinline{r <- (x + 1);}', the variable \lstinline{x} will be parsed as a local variable even though it can be used as a shared variable in other parts of the program, which may lead to the inconsistency of analysis.
In \porthos[2], all shared variables involved into a computation expression are tentatively copied to temporary local variables.

Fourthly, \porthos[1] supports only integer constants and expressions.
In \porthos[2], we extended support for primitive types supported by the \tool{Z3} solver (32-bit integers are encoded as \texttt{Int}s of \tool{Z3}, floats are encoded as \texttt{Real}s).
Although the \tool{Z3} supports the array theory (characterised by the select-store axioms~\cite{de2011z3}), the complexity of pointer analysis for the arrays of non-constant size moves the full support of arrays and pointers out of the scope of current thesis.

Finally, the grammar used by \porthos{} has the following minor drawbacks. %A minor drawback of 
The operators are non-associative (expressions of the form `\lstinline{1 + 2 * 3}' can not be parsed).
Comparing to C statements, which must end with the semicolon punctuator `\lstinline{;}', statements defined in the grammar of \porthos[1] use the semicolon as a separator between statements (the final statement must not end with semicolon).
The litmus test-specific syntax for variables initialisation is used only for declaring the shared variables (all of them are initialised with default value \lstinline{0}), however, this syntax should be used as an initial assignment of both shared and local variables with arbitrary values.

\porthos[2] uses the C language grammar of proposed in the C11 standard~\cite{c11}, that was extended by litmus test-specific syntax such as initialisation and final-state assertion statements (the original \tool{ANTLR} grammar can be found in the official repository containing the collection of \tool{ANTLR v4} grammars%
%
\footnote{ANTLR grammars repository path:~\url{https://github.com/antlr/grammars-v4}}). %
%
Current version of \porthos[2] does not recognise C processor directives (it ignores them), however, in future it can be extended to support them.


\section{Architecture}
\label{ch:impl:arch}

\begin{figure}%[H]
  \centering
  \includegraphics[height=.98\textheight,keepaspectratio]{img/my/draw.io/general_arch-no_numbering.png}
  \caption{The general architecture of \porthos[2]}
  \label{fig:arch}
\end{figure}

The general processing scheme of old tool \porthos[1] is the following.
The input program is parsed to the AST, where leaves are the events.
The instructions of the AST are then encoded into the $\phi_{CF}$ (see Section~\ref{ch:enc:bmc:cf}) and the events are processed by the single function (`\texttt{dartagnan.wmm.Domain.encode}') that loops over all events, checks their properties (the kind of event, the operands of the memory event, the type of the barrier event, etc.) and adds corresponding relations assertions to the formula.
Encoding all the relations (the \textit{program domain encoding}) in a single function is error-prone and hardly manageable.
Moreover, this function does not consider the memory model, therefore the result formula can contain relations that are not constrained by the memory model specified by the user and thus are redundant (for instance, the \texttt{TSO} memory model does not contain \texttt{POWER}-specific relations \texttt{ii}, \texttt{ic}, \texttt{ci}, etc., that are always encoded regardless the memory model).
In \porthos[2], we moved the encoding logic into a separate module \ref{ch:impl:proc:z-encoder} that accepts the input program and the user-defined memory model, therefore does not add constraints over unused relations to the result SMT-formula.

The high-level architecture of \porthos[2] is presented in Figure~\ref{fig:arch}.
The program takes as input the program to be analysed and one (the reachability analysis mode) or two (the portability analysis mode) memory models.
However, instead of parsing memory models from the \cat{} file, the tool may operate with pre-defined memory models (\texttt{SC}, \texttt{TSO}, \texttt{PSO}, \texttt{RMO}, \texttt{ALPHA}, \texttt{POWER}, \texttt{ARM}; this feature is inherited from \porthos[1]).
The parsed program syntax tree is then converted (Section~\ref{ch:impl:proc:y-constr}) to a program AST called \ytree{}%
%
\footnote{In order to avoid confusion between different internal representations, we prefix the names of elements of each internal representation with a letter. For instance, we picked the letter `Y' to denote the AST code representation as drawing of this letter resembles the tree branching; with letter `X' we prefix elements of the event-flow graph as the events are to be e\textbf{x}ecuted; and with letter `W' we prefix elements of the \textbf{w}eak memory model AST.}%
%
(Section~\ref{ch:impl:model:ytree}), which then is being preprocessed at the pre-compilation stage (Section~\ref{ch:impl:proc:x-pre-compiler}) in order to collect information necessary for the compilation.
The \ytree{} then is being compiled (Section~\ref{ch:impl:proc:x-compiler}) to an \xgraph{} representation (Section~\ref{ch:impl:model:xgraph}).
The compiled \xgraph{} then is being converted to an acyclic form (Section~\ref{ch:impl:proc:x-unroll}) in order to be encoded into a \zformula{} (Section~\ref{ch:impl:model:zformula}).
Apart from that, the memory-model constructor (Section~\ref{ch:impl:proc:w-constr}) constructs the abstract syntax tree of derived relations of the weak memory model \wmodel{} (Section~\ref{ch:impl:model:wmodel}).
%on the basis of the \xgraph{} in order to build the weak memory model \wmodel{} (Section~\ref{ch:impl:model:wmodel}).
Thereafter, \wmodel{} and acyclic \xgraph{} are encoded (Section~\ref{ch:impl:proc:z-encoder}) to a \zformula{} representation (a wrapper over an SMT-formula), which then is translated to an SMT-formula (Section~\ref{ch:impl:proc:smt-converter}), which then is solved by the SMT-solver (Section~\ref{ch:impl:proc:smt-solver}).


\subsection{Internal representations}
\label{ch:impl:model}

For keeping the architecture transparent, we build all abstraction levels with interfaces, even if some of them does not add any new functionality.

\subsubsection{Y-tree}
\label{ch:impl:model:ytree}

The first internal representation used by \porthos[2] is the \textit{\ytree{}}, which represents an untyped high-level recursively defined AST%
%
\footnote{Hereinafter we use the term \textit{recursive} data structure (also called \textit{inductive} data structure) to refer a complex data type that can contain elements of the same type.} %
%
. The Apendix~\ref{apx:trees} presents the file tree of the main classes that constitute the \ytree{} hierarchy (as the inheritance tree might be obvious for the C-like AST, we confine ourselves to presenting the classes file tree only, which we tend to retain clearly structured).

The abstract syntax tree, \ytree{}, is an abstraction level suitable for compiling the program to a low-level representation (in the case of processing low-level assembly code, it may be directly converted to the \xgraph{} representation).
In terms of \porthos[1], the \ytree{} is the level of \textit{instructions}.
%However, it lacks some concepts of the language (for example, the syntax of indexer access corresponds the grammar rule "\lstinline{postfixExpression '[' expression ']'}" for an arbitrary postfix %, that is converted to the \texttt{YIndexerExpression}).
However some details of the syntax might have been abstracted away (for instance, array operations may be emulated by functions invocations, see~\cite[Chapter 5]{gries2012science}), we find this level of abstraction suitable enough for modelling a high-level language.

Each \ytree{} element implements the interface \texttt{YEntity} and carries the \texttt{Origin} (original code coordinates) instance that contains information about the coordinates of the input text that has generated the \ytree{} element.
The origin can be translated to the code citation by the \texttt{CitationService}.

Following the C11 standard~\cite{c11}, we distinguish a \textit{statement} (\textit{"an~action to be performed"}) from an \textit{expression} (\textit{"a sequence of operators and operands that specifies computation of a value, or that designates an object or a function, or that generates side effects, or that performs a combination thereof"}).
All \ytree{} expressions implement the \texttt{YExpression} interface.
Although the pointer arithmetic is not fully supported by \porthos[2], the \ytree{} contains information about the \textit{pointer level} of an expression (which is modelled as an integer number). 
We distinguish the subset of expressions that imply no side-effects, they implement the interface \texttt{YAtom} and can be global or local (which is determined syntactically).

\vspace{1em}
The \ytree{} expressions are the following:

\begin{itemize}%[nolistsep]
  \item \texttt{YBinaryExpression} that model the C binary operator (\textit{relative} operator that compares two expressions of any type, \textit{logical} that processes two boolean expressions, and \textit{numerical} that processes two integer or real expressions);

  \item \texttt{YUnaryExpression} that model the C unary expression (logical negation, numeric prefix and postfix increment and decrement, bitwise complement);

  \item \texttt{YMemberAccessExpression} that has an arbitrary expression of type \texttt{YExpression} as its base expression (it will be resolved during the compilation stage, see Section~\ref{ch:impl:proc:x-compiler});

  \item \texttt{YIndexerExpression} and \texttt{YInvocationExpression} that as arbitrary expression as its base or arguments (strictly speaking, the indexer expression is an unary-function invocation, but as the SMT-solver we use supports the constant-array theory, we can maintain the array type);

  \item \texttt{YAssignmentExpression} that assigns an \texttt{YExpression} to an \texttt{YAtom};

  \item \texttt{YVariableRef} that stores the untyped "reference" to a variable (viz., the name only);

  \item \texttt{YLabeledVariableRef} that represents the litmus-specific local variable reference for a certain the process (e.g., `\lstinline{P0:x}' which means the local variable \lstinline{x} of the process \lstinline{P0});

  \item \texttt{YParameter} that represents a typed variable (the type was declared, similarly to the variable definition); and

  \item \texttt{YConstant} that represents an untyped non-named constant.
\end{itemize}

%\vspace{0.5em}
Similarly to expressions, all \ytree{} statements implement the \texttt{YStatement} interface. The statements are the following: 
%\textbf{(TODO: extract interface YStatement, create abstract class YStatementBase)} %TODO <--

\begin{itemize}%[nolistsep]
  \item \texttt{YBranchingStatement} representing the \texttt{if-then-else} statement;
  
  \item \texttt{YLoopStatement} representing both \texttt{while}- and \texttt{for}- loops;
  
  \item \texttt{YJumpStatement} representing unconditional jump (\texttt{goto}-jump to a label and loop-jumps \texttt{break} and \texttt{continue});
  
  \item \texttt{YCompoundStatement} (block statement) representing sequence of \textit{N} statements grouped into one syntactic unit;
  
  \item \texttt{YLinearStatement} representing a single expression; and
  
  \item \texttt{YVariableDeclarationStatement} containing the information about the variable type during the variable declaration.
\end{itemize}

On the \texttt{Y}-level of abstraction, we define the \texttt{YType} as a \textit{reference} for the type (since the \ytree{} is not typed, the \texttt{YType} is used for storing the type information on variables or types declarations).
It consists type modifiers and qualifiers, that will be converted to the X-type by the \texttt{Y2XTypeConverter} during the pre-compilation stage (see Section~\ref{ch:impl:proc:x-pre-compiler}).

According to the C standard, \textit{"any statement may be preceded by a prefix that declares an identifier as a label name"}.
The \ytree{} statements of follow this rule, however they these labels are symbolic, and they need to be resolved at the pre-compilation stage.
Apart from the set of statements listed before, we define the \texttt{YFunctionDefinition} and its inheritor a litmus-specific declaration \texttt{YProcessDefinition}
used in intra-procedural analysis mode.
The function definition contains the \texttt{YCompoundStatement} body and the \texttt{YMethodSignature} signature (method name and types of formal parameters), which is used in the function resolution during the pre-compilation stage.
The other litmus-specific statements are \texttt{YPreludeStatement}
that carries the list of \texttt{YStatement} initial writes, and \texttt{YPostludeStatement} 
that carries the \texttt{YExpression} binary expression to be asserted by the litmus test.

The syntax tree that contains set of definitions (e.g., litmus-initialisations, function definitions, litmus-asserts) is modelled by the class \texttt{YSyntaxTree}.


\subsubsection{X-graph}
\label{ch:impl:model:xgraph}

The \ytree{} is compiled into the low-level event-based program representation called \textit{\xgraph{}}.
The mathematical structure of event-flow graph was discussed in Section~\ref{ch:wmm:model}.
The nodes of the graph are events, and the edges are basic relations: the control-flow relation \po{} and the data-flow relations \co{} and \rf{}.
Hereinafter, we denote the \xgraph{} with only control-flow edges as \xgraph[CF], the \xgraph{} with only data-flow edges as \xgraph[CF].
The complete \xgraph{} is $\xgraph[CF+DF] = \xgraph[CF] \; \cup \; \xgraph[DF]$.
The UML diagram on Figure~\ref{fig:class-diagrams:XEntity-interfaces} represents the hierarchy of main interfaces of the X-abstraction level.
The \textit{full} list of classes that constitute the \xgraph{} hierarchy can be found in Appendix~\ref{apx:trees}.
Internally, the graph is represented by an adjacency matrix (to be exact, by multiple adjacency matrices that store edges of different kinds, see more details in Section~\ref{ch:impl:model:xgraph}).

\begin{figure}[t]%[!b]%[H]
  \centering
  \includegraphics[width=\textwidth,keepaspectratio]{img/my/class-diagrams/XEntity-interfaces.png}
  \caption{The inheritance tree of interfaces of \xgraph{}}
  \label{fig:class-diagrams:XEntity-interfaces}
\end{figure}

All elements of \xgraph{} implement the interface \texttt{XEntity}.
There are two main kinds of X-entity: \textit{events} that implement the \texttt{XEvent} interface, and \textit{memory-units} that implement the \texttt{XMemoryUnit} interface.

Following the format of litmus tests, we distinguish three types of \xgraph{}: one for the parallel processes, one for the litmus-initialisation block and one for the assertion statement.
However, all three types of the \xgraph{} are modelled by the same graph structure \texttt{XProcess} with certain restrictions complied by the corresponding type of X-interpreter that constructs the graph.
This simplifies drastically the processing of different types of code blocks as they all are modelled by the same data structure.
The examples of restrictions on X-graphs are the following: the initialisation block can not have branchings, fence events; the process cannot have assertion events; the assertion block can not have shared-memory events or fence events.
We discuss the interpretation of different types of statements in more detail in Section~\ref{ch:impl:proc:x-compiler}.


\paragraph{Memory units}
%\label{ch:impl:model:xgraph:mem}

An \textit{X-memory unit} is a memory cell of an abstract machine executing the code (that represents the \xgraph{}).
The abstract machine has infinite number of arbitrary-sized \textit{registers} (local memory units) and \textit{locations} (shared memory units).
Local memory units extend the \texttt{XProcessLocalElement} interface, that stores the ID of the owning process.
Figure~\ref{fig:class-diagrams:XMemoryUnit} represents inheritance hierarchy of memory units.

\begin{figure}[t]%[!b]%[H]
  \centering
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/my/class-diagrams/XMemoryUnit-m.png}
  \caption{The inheritance tree of \xgraph{} memory units}
  \label{fig:class-diagrams:XMemoryUnit}
\end{figure}

Following the terminology of the C standard, we distinguish the \textit{r-value} and \textit{l-value} memory units (unlike r-values, the l-values may be assigned a new value).
As r-values cannot change their value, they can be seen as the value itself (therefore the \texttt{XComputationEvent} is modelled as an local r-value memory unit, see more detailed discussion further in current Section).

Each memory unit has an \texttt{XType} associated with it.
The X-type is a symbolic representation of the C primitive type%
%
\footnote{Here we should note that \porthos[2] can eventually evolve to be able to analyse programs written in an OOP language (for instance, in C++). In this case, the \texttt{XType} will have more complex structure than a simple enumeration, which it has when we need to emulate only primitive types of C language. See more detailed discussion on input language type system in Section~\ref{ch:impl:proc:x-pre-compiler}.} %TODO!!!!! Check that XType is really a simple enumeration
%
that is easily convertible to an SMT-type (modelled by \texttt{ZType}). %TODO: add the class ZType
All X-memory units carry the boolean flag that indicates whether it has been resolved correctly by the X-memory manager.

The memory units are created and stored by the \texttt{XMemoryManager}, which provides interface for accessing memory units during compilation stage.
For more detailed description of memory management see Section~\ref{ch:impl:proc:x-compiler}.


\paragraph{Events}
%\label{ch:impl:model:xgraph:evt}

An \textit{X-event} represents the fact of executing the primitive operation, which is independent from other events.
Each X-event implements the \texttt{XEvent} interface and is carries the information about the process generated them and a unique event label, which is modelled by an immutable structure \texttt{XEventInfo}.
Each event should carry the reference to the Y-instruction that has generated it (this information can be useful for the unrolling discussed in Section~\ref{ch:impl:proc:x-unroll}, however currently each X-event contains the reference to the original code location, similarly to Y-instructions discussed above).

The following interfaces model basic kinds of events (see Figure~\ref{fig:class-diagrams:XEntity-interfaces}):

\begin{outline}
  \1 \texttt{XMemoryEvent} \\
  The memory event defines the transfer of the value from one memory unit to another.
  There are four types of memory events (the arrow denotes the direction of the data-flow):
  \2 \texttt{XRegisterMemoryEvent}: \\
    $(\texttt{XLocalLvalueMemoryUnit}) \leftarrow (\texttt{XLocalMemoryUnit})$,
  \2 \texttt{XLoadMemoryEvent}: \\
    $(\texttt{XLocalLvalueMemoryUnit}) \leftarrow (\texttt{XSharedMemoryUnit})$,
  \2 \texttt{XStoreMemoryEvent}: \\
    $(\texttt{XSharedLvalueMemoryUnit}) \leftarrow (\texttt{XLocalMemoryUnit})$, and
  \2 \texttt{XInitialWriteEvent}: \\
    $(\texttt{XLvalueMemoryUnit}) \leftarrow (\texttt{XRvalueMemoryUnit})$.

  %TO-DO: either say st about getLoc(), getReg(), or remove them from code
  
  \1 \texttt{XComputationEvent} \\
    We distinguish two types of computation events:
      \2 \texttt{XUnaryComputationEvent} that encodes bit negation and no-operation; and 
      \2 \texttt{XBinaryComputationEvent} that encodes numeric operations (such as addition, multiplication, etc.), bit vector operations (such as bit-and, bit-xor, etc.), relative operations (such as greater-then comparison, equality comparison, etc.), and logical operations (such as conjunction and disjunction). 
    \newline
    The computation event class implements both \texttt{XEvent} and \texttt{XMemoryUnit}.
    This is a model-level optimisation, which is possible because a computation event performs computation over local-only memory and does not change value of any memory unit.
    Thus, the \textit{computation} abstraction (as the CPU time spent for the computation itself) can be safely removed from the model, and the computation event can be seen as a zero-time operation that produces the \textit{value}.
    For analysing large expressions this optimisation is sensible because it considers the whole expression as a single computation event, encoded therefore as a single SMT-variable.
    \newline
    Note, for the purpose of simplifying the X abstraction level, computation events may have been modelled as invocations of bodiless functions (for instance, the operation `\lstinline{x + y}' may be modelled as the invocation of the function `\lstinline{+}' with the arguments \lstinline{x} and \lstinline{y}).
    However, current version of \porthos[2] maintains the \texttt{XComputationEvent} as the operators are supported by the SMT-solver.

  \1 \texttt{XControlFlowEvent} \\
    The control-flow event indicates a non-linear jump in the code. We distinguish two kinds of control-flow events: 
    \2 \texttt{XJumpEvent} that performs no computation and no data operation, it can be safely removed from the model as an optimisation; and
    \2 \texttt{XFunctionCallEvent} that models function invocations.
    The function call also implements the \texttt{XLocalMemoryUnit} since it represents the computed value returned by the function call.
    Currently, \porthos[2] only supports invocations of the method calls registered in its knowledge base (see invocation hooking mechanism described in Section~\ref{ch:impl:proc:x-compiler}).
    For interpreting known function invocations, \porthos[2] must perform three steps: bind actual arguments to the formal parameters (treated as temporary registers as in the \texttt{fastcall} calling convention), push the called \texttt{XFunctionCallEvent} onto the call stack, and the perform the control-flow jump to the function body.
    The call stack must be bounded by the user-defined parameter; once the stack is full, the interpretation should continue without jumping to the body of the invoked function (such cases must be properly logged).
    Each \texttt{return} statement must create the assignment of the function call event that is on the top of call stack.
    Note, this approach will work for recursion as well, and the recursive calls together with loops must be unrolled up the user-defined boundary (see Section~\ref{ch:impl:proc:x-unroll}).
    The discussion on how to set up the \po-relations in the event-flow graph with recursive function calls can be found in~\cite{musketeer2014recursion}.
    \\
    If the function has not been resolved, it can be safely assumed to be a no-operation function (with proper logging).
    In other words, we suppose that the knowledge base of \porthos[2] is complete and the tool can resolve all memory-operation functions and fence instructions.
    Although this can affect the completeness of the analysis, it is safe to make such an assumption as the user can check the log file and manually analyse the semantics of an unresolved call and add it to the knowledge base if necessary.

  \1 \texttt{XFenceEvent} \\
    The fences are implemented as an enumeration \texttt{XBarrierEvent}.
    Current implementation of \porthos[2] supports all fences supported by \porthos{}: 
    \texttt{mfence}, \texttt{sync}, \texttt{optsync}, \texttt{lwsync}, \texttt{optlwsync}, \texttt{ish}, \texttt{isb}, and \texttt{isync}.
    
  \1 \texttt{XFakeEvent} \\
    The fake events are the auxiliary elements of \xgraph{}.
    \2 \texttt{XEntryEvent}, the per-process unique source event in the event-flow graph,
    \2 \texttt{XExitEvent}, the process sink event,
    \2 \texttt{XNopEvent}, the no-operation event (a jump to the next event), used for correct encoding in case when the control-flow branch does not have any event (see Figure~\ref{encode:branching:nop}), and
    \2 \texttt{XAssertionEvent}, the reachability assertion made at the postlude statement of the program.
    An assertion is modelled as an event for the purpose of encoding the postlude statement as a separate process that is compatible with the Z-encoder.

\end{outline}


\paragraph{Edges}
%\label{ch:impl:model:xgraph:edges}
As the graph is represented by an adjacency matrix, its edges are stored in immutable hash-maps.
We distinguish the following kinds of edges:

\begin{outline}
  \1 the \textit{control-flow edges}:
    \2 the \textit{primary edges}, that denote both $\epsilon$-labelled transitions (in case of linear sequence of events) and conditional transition that evaluates the conditional event (the source of the transition) to the \textit{true}, and
    \2 the \textit{alternative edges}, that denote conditional transitions for which the conditional event (the source) was evaluated to the \textit{false}; and
  \1 the \textit{data-flow edges}:
    \2 the \co{}-relation edges, and 
    \2 the \rf{}-relation edges.
\end{outline}


\paragraph{Graph invariants}
%\label{ch:impl:model:xgraph:invariants}
Once being constructed, the graph must conform the following requirements (see also Section~\ref{ch:wmm:model:events}):

\begin{enumerate}[noitemsep]
\item the graph must have a single source with no ingoing edges, and two sinks of different kinds without outgoing edges,
\item the graph must be connected,
\item each node of the graph can have either one or two direct control-flow successors,
\item only nodes of type \texttt{XComputationEvent} can have two direct control-flow successors,
%\item each node except the source node must have at least one parent
\item a \co{}-edge connects two writes, an \rf{}-relation edge connects a write and a read,
\item all write-event nodes except initial write-nodes must have exactly one \co-predecessor, and
\item all write-event nodes except final write-nodes must have exactly one \co-successor.
\end{enumerate}

%\paragraph{Graph builder} % TODO: in code: remove graph hierarchy by combining unrolled and normal. Add a bool 'UnrolledStatus' -- thus we can keep genericity
%TO-DO: code : NOTE: 'FlowGraph<N extends FlowGraphNode>' may be just 'FlowGraph<N>'


\subsubsection{W-model}
\label{ch:impl:model:wmodel}

The \textit{\wmodel{}} represents a recursive AST of \textit{computation over relations} and \textit{assertion expressions} defined by the memory model.
The atomic elements of \wmodel{} are the basic relations (\po{}, \rf{} and \co{}; see Section~\ref{ch:wmm:model:relations}) and sets of events ($\mathbb{R}$, $\mathbb{W}$, $\mathbb{IW}$, etc.; see Section~\ref{ch:wmm:model:events}).
The expressions of \wmodel{} are unary (such as complement, transitive closure, etc.) and binary operations (such as union, intersection, etc.) over relations or sets of events; see Section~\ref{ch:wmm:cat}.
Each element of \wmodel{} implements the interface \texttt{WModel}, and for the sake of transparency contains the origin location in the model file. %TODO: implement origin for w-model
As the \wmodel{} hierarchy almost completely follows the mathematical structure discussed in Sections~\ref{ch:wmm:cat} and~\ref{ch:enc:bmc:wmm}, we skip the details of its implementation.


\subsubsection{Z-formula}
\label{ch:impl:model:zformula}

The \textit{\zformula{}} representation is supposed to be a wrapper over an SMT-formula used as an additional abstraction level to increase the transparency of the architecture, simplify the debugging process and ease the support of different SMT-solvers.
However, currently \porthos[2] skips this internal representation and both the program and memory models directly into the SMT-formula via Java API offered by the Z3 solver.
%As all other internal representations, the \zformula{} should be implemented as an immutable data structure.

The Z-abstraction level should model the logical formulas (definitions and assertions) that are put on the assertion stack of the SMT-solver.
Generally, a \zformula{} should represent the S-expression-based syntax of the SMT-LIB language~\cite{smt-lib}.
Currently, the \zformula{} is supposed to represent definitions and assertions over variables and binary and unary expressions.
However, for the purpose of improving the encoding scheme, it may be extended to support function symbols and binders (existential and universal quantification, pattern matching and functional type construction).

All expressions of a \zformula{} must be \textit{typed} (or \textit{sorted}, in terms of SMT-LIB standard).
Basically, the Z-type must support boolean and numeric (integer, bitvector, real) expressions.
The typing of a \zformula{} is necessary for checking the basic validity of its expressions and converting it to a typed SMT-formula.
For the sake of transparency, each element of a \zformula{} should contains the origin location as the reference to the X-element that produced current Z-element.


\subsection{Processing units} %Transformation}
\label{ch:impl:proc}

This section describes program units that construct, transform and analyse internal representations described above.
%not anymore %Each processing unit is assigned with a unique number, which can checked in Figure~\ref{fig:arch} (within gears depicted in the top-left corner of each processing unit).

The construction of the \xgraph{} is performed in three stages.
Firstly, the \ytree{} is compiled to a \textit{cyclic} control-flow event-based graph \xgraph[CF].
Then, this graph is unrolled to an \textit{acyclic} control-flow event-based graph \xgraphU[CF].
After that, the compiler is able to perform the data-flow analysis over the \xgraphU[CF] and produce the full event-based graph \xgraphU[CF+DF], which remains to be \textit{CF-acyclic} (no cycles among control-flow edges).

Most data structures are processed by units that implement the \textit{visitor} pattern~\cite{palsberg1998essence}.
This is a behavioural pattern that separates the program logic from the object implementation by specifying handling methods for each element of the object.
The general structure of the visitor pattern is illustrated by the pseudo-java code in Figure~\ref{fig:visitor}.
The visitor pattern performs the double-dispatching, a mechanism for decreasing the cohesion between the DTO (the visitee) and the processor class (the visitor): the visitee implements the \textit{accepting} method that gets the visitor as an argument and invokes its \textit{visiting} method with itself as an argument.
Thus, the method call resolution is performed statically at compile-time without any overhead at run-time.
In our implementation, the visitor (not the visitee) cares about the continuation of traversing its children.

\begin{figure}[h]
\centering
\begin{minipage}[t]{.55\textwidth}
\begin{lstlisting}[language=java]
interface Element {
  <T> T accept(Visitor<T> visitor);
  ...
}

class AnElement implements Element {
  @Override
  <T> T accept(Visitor<T> visitor) {
    return visitor.visit(this);
  }
  ...
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=java]
class Visitor<T> {
  T visit(AnElement e) {
    // visiting logic
    ...
    // continue recursively
    e.getChild().accept(this);
  }
  T visit(AnOtherElement e) {
    ...
  }
  ...
}
\end{lstlisting}
\end{minipage}
\caption{Illustration of the visitor pattern}
\label{fig:visitor}
\end{figure}

We consider the visitor pattern as the most natural way for operating the hierarchical data structures such as AST.
However, we use its double-dispatching capabilities to reduce cost of multiple type casting performed while traversing the elements of a non-recursive data structure.
The operator instance, instead of having a single method that handles and element of the instance, extends the visitor interface and splits the handler method into multiple methods, one for each type of element.

For traversing plain data structures (such as graphs), we mostly follow the \textit{iterator} pattern: the special object \texttt{Iterator}, that has access to elements of the data structure, iterates over them in some order (for example, in topological order as it is implemented for \xgraph{}).
The construction of immutable data structures is performed by units that follow the \textit{builder} pattern.
A builder is a mutable object that contains methods for "filling" it with the elements that will constitute the result complex object.
The methods contain basic validity checks of the elements.
Once a builder has been built, it cannot be modified.


\subsubsection{Input parsers}
\label{ch:impl:proc:input-parser}

As it was discussed in Section~\ref{ch:impl:input}, both input-language and input-model parsers are implemented via \tool{ANTLR} parser generator.
Currently, \porthos[2] does not consider C preprocessor instructions (it ignores them).
For implementing the inter-procedural mode of \porthos{}, it is crucial to support inclusion of header files (the \texttt{\#include} preprocessor directive).
Next step would be implementing the support of macros and conditional compilation directives, that are used often in C code.
As preprocessor statements may appear in arbitrary place of a program, the preprocessor must be a stateful processing unit that reads the token stream and dynamically instrument the program by interpreting directives and expanding macros.

The input memory model language \cat{} is discussed in Section~\ref{ch:wmm:cat}.
The \tool{ANTLR} grammar for \cat{} language was extracted from the parser used by \tool{herd} tool%
%
\footnote{The \tool{herd} project repository: \url{https://github.com/herd/herdtools7}} %
%
written in OCaml.
%TODO: upload the grammar to github


\subsubsection{W-model constructor}
\label{ch:impl:proc:w-constr}

%TODO: <not implemented yet>
The \wmodel{} representation is constructed by the stateless visitor \texttt{Cat2WmodelConverterVisitor} from the ANTLR syntax tree \texttt{CatParser.MainContext} of the memory-model defined in \cat{} language.
Currently, the visitor supports the small subset of \cat{} language, which constitutes only non-functional declarative expressions of the language as the support for functional-style expressions requires implementing the full interpreter for OCaml-like language.
However, some most commonly used functional-style expressions may be supported by mapping them syntactically to corresponding W-elements directly in the \wmodel{} constructor.

Following the principle of transparency, the \wmodel{} constructor aborts its work with the \texttt{NotSupportedException} if met the unsupported syntax construction (in contrast to the \porthos[1] approach in which the \texttt{null} value was produced in all exceptional states).

%todo: file tree of w-model to appendix -- after implementing + more discussion here


\subsubsection{Y-tree constructor}
\label{ch:impl:proc:y-constr}

The \ytree{} is constructed by the stateless visitor \texttt{C2YtreeConverterVisitor} from the ANTLR syntax tree \texttt{C11Parser.MainContext} of the C language.
The \ytree{} constructor aborts its work with the \texttt{YParserNotImplementedException} once it meets an unsupported syntax construction.
A syntax exception \texttt{YParserException} is thrown if the converted syntax tree contains semantic errors that prevent it to be converted to the \ytree{}.

As a \ytree{} constitutes a generic AST, the \ytree{} constructor expands the syntactic sugar expressions and statements (for example, a \texttt{switch}-statement is converted to the equivalent \texttt{if}-statement).


\subsubsection{X-graph pre-compiler}
\label{ch:impl:proc:x-pre-compiler}

The precompiler traverses the \ytree{} and collects information necessary for its compilation into an \xgraph{}.

%TODO: <not implemented yet>


\paragraph{The label resolution}
%\label{ch:impl:proc:x-pre-compiler:label}

%TODO: <not implemented yet>

The label resolution is necessary for establishing links to labelled statements.
In C, labelled statements are declared via the colon-syntax `\texttt{<label>\;:\;<statement>}', and the labels are referenced by the jump-statement `\texttt{goto\;<label>}'.
The label resolution algorithm traverses the \ytree{} and collects all declared labels into a map that points a label to the labelled statement.
This information is used during compilation to set up unconditional jumps.


\paragraph{Type analysis}
%\label{ch:impl:proc:x-pre-compiler:type}

C language has a static (resolved at compile-time) manifest (all types are declared explicitly) type system.
Comparing to languages that use type inference, the type analysis of a C program constitutes a simple propagating the type information (obtained from variables declarations) to all expressions.
Being carried at Y- and X- representation levels, the type is converted to a~Z-type at the stage of the Z-formula encoding (see Section~\ref{ch:impl:proc:z-encoder}).

Currently, \porthos[2] handles only the primitive C types (such as \texttt{int}, \texttt{char}, \texttt{float}, etc.), which are modelled on the X-level by the enumeration \texttt{XType}.
%TODO: describe the XType (before) + implement this clearly! + definitely get rid of bit32
%The array dimension is stored at the Y-level as an integer number (currently this information is not used as \porthos[2] does not support arrays, although this information can be used at the stage of pre-compilation for converting array elements to separate variables). %the array operations are converted to ).
%In addition, \porthos[2] has a built-in extensible database storing the semantics of non-primitive C types stored by the \texttt{X2ZTypeConverter},
%which can be requested for converting an X-type to a~Z-type. %TODO: implement this.
The type analysis algorithm should consider the type aliases supported by C language (defined by the \texttt{typedef} instruction), which is not implemented yet.
For resolving the type aliases, the precompiler should make an extra traverse of the \ytree{} before the pre-compilation stage and build up a symbol map.

%<not needed below>
%The type analysis also includes the process of resolving semantics of function invocations.
%The result is stored in a map of invocation expression to the resolved function signature, so that the compiler can decide either to jump to the function body and interpret it, or to hook the invocation if the semantics of the function is resolved.
%However, due to lack of polymorphism and function overloading mechanism inherent to OOP languages, the function resolution algorithm may set up the mapping only for the function name and thus may neglect analysis of types of the arguments, we build the mapping for the full function signature so that the type analysis processing unit may be used for analysing the C++ code if needed.


\paragraph{Variable kind analysis}
%\label{ch:impl:proc:x-pre-compiler:var}

On the compilation stage, once the compiler meets the reference to a variable, it should know whether it refers to a local or global variable.
The kinds of variables have to be determined on the pre-compilation stage.

The following types of variables are detected as \textit{global variables}:
%TODO: <not implemented yet>
\begin{itemize}[noitemsep,topsep=0pt]
\item a variable was declared as a pointer;
\item a variable whose address was accessed by any process;
\item a variable declared as a parameter of the process function; and
\item a variable exported by the \texttt{extern} keyword (in the kernel-analysis mode, the functions \texttt{EXPORT\_SYMBOL} and \texttt{EXPORT\_SYMBOL\_GPL} also export symbols for dynamic linking~\cite{argawal16kernel}).
\end{itemize}


\subsubsection{X-graph compiler}
\label{ch:impl:proc:x-compiler}

The \textit{X-compiler} is the main component that transforms the recursive \ytree{} data structure to the plain \xgraph{} representation.
It is a complex processing unit; Figure~\ref{fig:compiler} illustrates the relationship between main components of the X-compiler in the UML language.

\begin{figure}[!t]%[H]
    \centering
  %draft=true
  \includegraphics[max width=\textwidth,keepaspectratio]{img/my/draw.io/X-compiler.png}
  \caption{Main components of the X-compilation processing unit}
  \label{fig:compiler}
\end{figure}

The main class representing the X-compiler is \texttt{Y2XConverter}. %TODO: draw it on Figure.
It receives as input the \ytree{}, the memory model kind and user settings (for instance, the interpreter mode defining the set of invocation hooks enabled during the analysis run).
The \texttt{Y2XConverter} creates an instance of the stateless visitor \texttt{Y2XConverterVisitor} that traverses the \ytree{} while invoking the stateful interpreter \texttt{XInterpreter}.
The \texttt{XInterpreter} carries the \xgraph{}-builder and provides \textit{action} methods for changing its state and thus the filling in the builder.
The interpreter has additional modules \texttt{XMemoryManager}, \texttt{XHookManager} and \texttt{XTypeManager} that provide specialised functionality.

We distinguish three types of interpreters (each implementing the \texttt{XInterpreter} interface):
\begin{itemize}[noitemsep,topsep=0pt]
\item the \textit{program} interpreter \texttt{XProgramInterpreter} that is the compositional element that dispatches calls to currently maintained process interpreter;
\item the \textit{prelude} process \texttt{XPreludeInterpreter} (to be executed before all other processes) that allows only declaration of local or shared variables, computations and memory operations;
\item the \textit{postlude} process \texttt{XPostludeInterpreter} (to be executed after all other processes) that allows only declaration of local variables, memory operations, computations and assertions;
\item the \textit{process} \texttt{XProcessInterpreter} (to be executed in parallel) that allows all X-compiler interface operations except declaration of shared variables
and program assertions (i.e., it allows declarations of local variables, computations, barriers, unconditional jumps, non-linear branching statements, and method calls).
\end{itemize}

As the prelude process can declare shared variables, its compilation must go first.
%TODO: sort processes at the pre-compilation stage !
The first event of each process must be the \texttt{XEntryEvent} and the last events must be events of type \texttt{XExitEvent}.


\paragraph{Memory manager}
%\label{ch:impl:proc:x-compiler:mem}

The \xgraph{} abstract machine model disposes infinitely many memory units, both local and shared (see Section~\ref{ch:impl:model:xgraph}).
The X-compiler accesses all memory units via the \texttt{XMemoryManager}, which by the end of pre-compilation stage is already initialised (has registered all shared memory units).
However, the memory manager is a stateful component of the compiler as it offers the methods for declaring and removing local memory units dynamically at the compilation time.

The interface methods exposed by the \texttt{XMemoryManager} are presented in Figure~\ref{fig:mem-manager}.
At each time of the compilation process, the \texttt{XMemoryManager} can resolve the memory unit by its name.
Following the C standard, local memory units have higher priority over global ones (the method \texttt{getDeclaredUnitOrNull} returns the first memory unit found, either a global one or a local one, or null if no memory units with requested name have been registered).
Since C language allows usage of variables that have the same name to be declared in nested contexts, the \texttt{XMemoryManager} should carry the stack of block contexts for local variables (which is not currently implemented).

\begin{figure}[h]
\centering
\lstinputlisting[language=java]{inc/lst/XMemoryManager.java}
\caption{X-memory manager public interface}
\label{fig:mem-manager}
\end{figure}


\paragraph{Invocation hooking manager}
%\label{ch:impl:proc:x-compiler:hooking}

The invocation hooking module serves as a knowledge base that stores the semantics of functions.
Once the X-compiler meets the function invocation, it calls the \texttt{XHookManager}, which tries to match the function signature (in the case of program in C language -- only the function name) across all signatures it stores.
If the signature matches, the hook manager intercepts the function call and interprets the hook action instead of invoking the function directly.
The hook manager enables only invocation hooks that are compliant with the language of the input program.
All invocation hooks implement the interface \texttt{XInvocationHook}.
The result of an invocation hook interception is the \texttt{XInvocationHookAction}, a delayed operation implemented on the top of lambda functions of Java.
The hook action is invoked with actual arguments and returns an arbitrary \texttt{XEntity} as the result of invocation.

Current version of \porthos[2] contains two invocation hooks, the \texttt{XLegacyInvocationHook} for intercepting the compatibility-mode functions of the \porthos[2] input language, and \texttt{XKernelInvocationHook} for describing the Linux kernel-specific functions.
The same mechanism (with minor modifications) can be used for processing assembly language calls.
An invocation hook can model any type of operations (memory, fence, computational, etc.).
For instance, the \texttt{XKernelInvocationHook} intercepts the invocation \lstinline{`WRITE_ONCE(dst_shared, src_local)'} and replaces it with the hook action shown in Appendix~\ref{apx:hook} (as the functions \texttt{READ\_ONCE}, \texttt{WRITE\_ONCE}, and \texttt{ACCESS\_ONCE} may be modelled as volatile \texttt{memory\_order\_relaxed} accesses~\cite{kernel2c}, this invocation hook simply emits a memory event without emitting any synchronisation events).


\paragraph{Interpreter}
%\label{ch:impl:proc:x-compiler:compilation}

The X-program interpreter is invoked by the \texttt{Y2XConverterVisitor} which recursively walks down the \ytree{}.
The calls to the X-program interpreter are dispatched to currently maintained X-process interpreter.
To be able to properly recognise nested statements of the \ytree{}, the X-process interpreter needs to have stacks.
On any semantic error, the X-interpreter throws an \texttt{XInterpretationError}.

The interface methods of the \texttt{XInterpreter} are presented in Appendix~\ref{apx:xinterpreter}.
Note the clear modular independence of the X-interpreter: it knows nothing about \ytree{} or other internal representations, all its interfaces use only X-level elements (all conversion with Y-entities is done by the \texttt{Y2XConverterVisitor}).

All interface methods of the X-interpreter can be divided into two groups.
The first group constitute methods that emit events.
These methods construct an event object (as events contain the \texttt{XEventInfo} structure that stores information about the owning process, all events must be created by the process constructor, i.e. X-interpreter) and change the state of interpreter considering the newly created event.
Note that the methods \texttt{createComputationEvent} do not emit a computation event but only create one.
This is an optimisation that removes unused computations from the model
(otherwise, for instance, the assignment `\texttt{x = 1 * (2 + 3)}' would be compiled into two consequent events `\texttt{eval(2 + 3); write(register <- eval(1 * eval(2 + 3)));}' instead of a single event `\texttt{write(register <- eval(1 * eval(2 + 3)));}').
Note, if the computation event has not been used at all (for example, in the following C code: `\texttt{foo(); 1; bar();}' the execution event `\texttt{eval(1)}' is skipped by the model), it is also removed from the event-graph (see justification in Section~\ref{ch:impl:model:xgraph}).
The second group of X-interpreter methods consists of the methods for defining non-linear statements (branchings and loops).
These methods change the state of the interpreter and set up additional non-linear control-flow edges.

As a high-level (Y-level) instruction may be compiled into a sequence of low-level instructions (for example, a computation that involves shared variables should firstly load them into the local memory and then process the computation event over local-only memory), the interpreter must maintain the \textit{stack of contexts} and remember the \textit{previous event} to be able to correctly process nested non-linear statements of C language.
The context is a data structure that carries the \textit{state} and some additional information in the case of processing non-linear statements (e.g., conditional event, first and last then- and else-branch events for binding, etc.).
Once the new event has been emitted, the interpreter sets up control-flow edges w.r.t. state of the context on the top of the stack.
The context stack is always non empty: the bottom context is the linear one that sets up the primary edge from the previous-event (last processed) to the currently processed one and updates the previous-event.
The context state is an enumeration of the following values:
\begin{itemize}[noitemsep,topsep=0pt]
\item \texttt{WaitingAdditionalCommand}: the interpreter is in the state of defining the complex (non-linear) statement and is not able to process any new event (will throw an exception if any) until the state is not changed;
\item \texttt{WaitingFirstConditionEvent}: the first next emitted event will be accepted as the first event of the condition evaluation (later, the loop edges will be set to this event);
\item \texttt{WaitingLastConditionEvent}: the next event must be of type \texttt{XComputationEvent}; it will be saved as the conditional branching event;
\item \texttt{WaitingFirstSubBlockEvent}: the first next emitted event will be accepted as the first event of the branch (later the interpreter will set up jumps to that event);
\item \texttt{WaitingNextLinearEvent}: the default interpreter state for processing next linear event, and
\item \texttt{Idle}: the interpreter does not set up the edge from the previous event to the new event.
\end{itemize}

Each new event emitted by the interpreter is processed considering the state of the context stack:
the interpreter iterates over the context stack and sets up the edges by the graph builder depending on the state of each stack.
The state \texttt{WaitingFirstConditionEvent} is necessary for correctly interpreting the branching conditions, which shared variables are involved in.
If the non-linear statement is a loop statement, the loop back-edges will be set to this event.

Once interpretation of the (non-linear) branch is completed, its non-linear context is being popped out of the context stack (by interpreter method \texttt{startBlockBranchDefinition}) and added to the queue of \texttt{almostReadyContexts}.
The almost-ready-context becomes a ready-context (i.e., it moves to the queue \texttt{readyContexts}) once the non-linear statement definition has finished (the method \texttt{finishNonlinearBlockDefinition}).

Before processing a newly emitted event, the interpreter checks whether the queue \texttt{readyContexts} is not empty.
If so, it iterates over all ready-contexts and sets up control-flow edges considering that the newly emitted event is an exit-event" of the non-linear context (e.g., for a branching context the interpreter adds primary edges from condition-event to the first-true-branch-event and from the last-true-branch-event to the exit-event, the same is done with alternative edges for the false-branch).
For the sake of simplicity of the interpretation and encoding, jump events (no-computation events) are present in the flow-graph, however they can be removed from it with rebinding ingoing and outgoing edges.
As an example of usage the interpreter, consider the code of the \texttt{Y2XConverterVisitor} for processing \texttt{if-then-else} statement of the \ytree{} in Appendix~\ref{apx:y2x}.


\subsubsection{X-graph unroller}
\label{ch:impl:proc:x-unroll}

In order to be encoded into an SMT-formula, the compiled graph needs to be acyclic~\cite{Porthos17b}.
For that, we perform the \textit{unrolling} (also called \textit{unwinding}) transformation: all cycles are unrolled so that the result number of events in a trace of the \xgraph{} does not exceed the user-defined bound $k$%
%
\footnote{The original specification of \porthos[2] stated that the unrolling bound $k$ must be interpreted as the maximum number of instruction in the original code (technically, the number of expressions in the ANTLR syntax tree).
Nonetheless, current implementation of the \xgraph{} unroller counts the X-level events as it is much simpler to implement (the questions about how to count complex expressions that involve multiple shared variables and method invocations are left open for the future versions of \porthos[2]).
For now, the information about the element of the ANTLR tree that corresponds to the X-event or Y-tree element is being lost during the transformations.
Instead, we use the \texttt{CitationService} discussed in Section~\ref{ch:impl:model:ytree} that in perspective may be extended for providing this information along with the text citation of the original code.}
%
.
This definition of the unrolling bound differs from one used by \porthos[1], where each cycle was executed $k$ times.
The meaning of a bound was changed in order to increase predictability of the size of the result SMT-formula.
Note that recursive function calls create unconditional back-jumps in the event-flow graph, which can also be recognised as a loop and be affected by the unrolling algorithm (however, currently not supported).

Considering the new meaning of the unrolling bound, the execution in the unrolled graph can be \textit{completed} (the loop has been executed a whole number of times) or \textit{uncompleted} (the unrolling bound has triggered on not-the-last event of the loop), which can be modelled by two types of the sink events.
The user may need this information for understanding how the \porthos[2] interprets the cyclic program.
However, current implementation loses this information by having only one sink event.
Figure~\ref{fig:loop-unroll} illustrates the unrolling for the left-hand side cyclic control-flow graph (the square node $S_{+}$ denotes the sink node for completed executions, and the $S_{-}$ denotes the sink for uncompleted executions).

\begin{figure}[t]
\centering
\resizebox{\linewidth}{!}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below left of=1] {$2$};
\node[c] (3) [below right of=1] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [bend left=50,dotted] node {} (1)
(1) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=80,dotted] node {} (1)
;
\node[draw=none] (impl) [right=3cm of 3] {$\overset{k = 6}{\longmapsto}$};
;
\node[c] (22) [right=3cm of impl] {$2_2$};
\node[c] (11) [above right=1cm and 1cm of 22]{$1_1$};
\node[c] (32) [below right=1cm and 1cm of 11] {$3_2$};
\node[c] (43) [below of=32] {$4_3$};
\node[c] (13) [below of=22] {$1_3$};
\node[c] (24) [below left=1cm and 1cm of 13] {$2_4$};
\node[c] (34) [below right=1cm and 1cm of 13] {$3_4$};
\node[c] (14) [below of=43] {$1_4$};
\node[c] (15) [below of=24] {$1_5$};
\node[c] (45) [below of=34] {$4_5$};
\node[c] (25) [below of=14] {$2_5$};
\node[c] (35) [below of=14] {$3_5$};
\node[c] (26) [below left=1cm and 1cm of 15] {$2_6$};
\node[c] (36) [below right=1cm and 1cm of 15] {$3_6$};
\node[c] (16) [below right=1cm and 0.2cm of 45] {$1_6$};
\node[c] (46) [below right=1cm and 0.3cm of 35] {$4_6$};
\node[rectangle,draw] (6inc) [below left=1cm and 3cm of 16] {$S_{-}$};
\node[rectangle,draw] (6com) [right=3cm of 6inc] {$S_{+}$};
\node[] (k1) [right=3.2cm of 11] {$(k = 1)$};
\node[] (k2) [right=1.7cm of 32] {$(k = 2)$};
\node[] (k3) [right=1.7cm of 43] {$(k = 3)$};
\node[] (k4) [right=1.7cm of 14] {$(k = 4)$};
\node[] (k5) [right=1.7cm of 35] {$(k = 5)$};
\node[] (k6) [right=1cm of 46] {$(k = 6)$};
\path[->]
(11) edge [] node {} (22)
(11) edge [] node {} (32)
(32) edge [] node {} (43)
(22) edge [] node {} (13)
(13) edge [bend right=10] node {} (24)
(13) edge [bend left=10] node {} (34)
(43) edge [] node {} (14)
(24) edge [] node {} (15)
(34) edge [] node {} (45)
(14) edge [] node {} (25)
(14) edge [] node {} (35)
(15) edge [bend right=10] node {} (26)
(15) edge [bend left=10] node {} (36)
(45) edge [] node {} (16)
(35) edge [bend right=10] node {} (16)
(35) edge [bend left=10] node {} (46)
(26) edge [bend right=10] node {} (6com)
(36) edge [bend right=5] node {} (6inc)
(16) edge [bend left=20] node {} (6inc)
(46) edge [bend left=20] node {} (6com)
;
\end{tikzpicture}
}
\caption{Example of the flow graph unrolling up to bound $k = 6$}
\label{fig:loop-unroll}
\end{figure}

The unrolling procedure is performed by the \texttt{XFlowGraphUnroller}.
For unrolling the flow-graph, we perform the \textit{Deep-First Search~(DFS)} while counting the X-events (for the unrolling bound) and keeping track of the depth stack (for detecting back edges needed for determining the type of sink node).
Back-edges are determined via the depth stack (each next event is pushed onto the stack; if the new event is present in the stack, the last processed edge is a back-edge).
Also, during the unrolling each next event increments the \textit{unrolling depth counter} (the \textit{event reference-ID}) -- the integer stored by the \texttt{XEvent} thus making it an \textit{event reference} on non-zero values (only events of a non-unrolled graph can have the zero-valued reference-ID).
As an X-event is immutable, it has the method `\texttt{XEvent asNodeRef(int refId)}' that clones it with new value of reference-ID.
The methods \texttt{hashCode} and \texttt{equals} consider the reference-ID as the uniqueness field for all events except sink and source events (considering the usage of \texttt{HashMap} and Guava's \texttt{ImmutableMap} for storing events, proper setting of the hash-code methods is a crucial programming task).

%During the work on \porthos[2], we have tested several different schemes of loop unrolling.


\subsubsection{X-graph data-flow constructor}
\label{ch:impl:proc:x-df}

Once the graph is unrolled, it can be augmented by data-flow edges.
As it was discussed in Section~\ref{ch:impl:model:xgraph}, the data-flow edges can represent either \rf{}- or \co{}-relation.
The \rf{}-edges join each write event to all read events that access the same location; the \co{}-edges join write events to the same location.
Currently, \porthos[2] does not yet construct the \xgraph[DF] component of the full \xgraph{}, instead, it uses the function `\texttt{dartagnan.wmm.Domain.encode}' of \porthos[1] to encode data-flow relations and derived relations of the \xgraph[CF].

%TODO: why in old implementation we encode the negation of "co" ? same for "rf" above
%\url{https://github.com/hernanponcedeleon/Dat3M/blob/80341bec26021d41cf79eddc943e7cbe6f49322f/dartagnan/src/dartagnan/wmm/Domain.java#L204} >


\subsubsection{Z-formula encoder}
\label{ch:impl:proc:z-encoder}

The \zformula{} encoder accepts as input the unrolled X-graph and the input memory models.
It visits the recursive memory model AST and each its derived relation definition (recall the `\texttt{let}' keyword of the \cat{} language) it transforms to the set of SMT-clauses, generated on the basis of the program events with respect to the encoding scheme described in Chapter~\ref{ch:enc}.
As the \zformula{} representation is not yet implemented, the \zformula{} encoder encodes the \xgraph{} and \wmodel{} directly into the SMT-formula via Java API of the Z3 solver (the program domain encoding is currently a part of the \zformula{} encoder until the full \xgraph[CF+DF] is implemented).


%\subsubsection{SMT-formula converter}
%\label{ch:impl:proc:smt-converter}
%
%As the \zformula{} follows the SMT-LIB standard, its translation to an SMT-formula constitutes almost one-to-one mapping.
%The translation should be performed by the stateless visitor \texttt{Z2SmtTranslator}.
%
%
%\subsubsection{SMT-solver}
%\label{ch:impl:proc:smt-solver}
%As it has been mentioned in Section~\ref{ch:impl:principles}, \porthos[2] uses the third-party SMT-solver \tool{Z3}, which offers the Java API for constructing requests to the Z3 solver and interpreting its responses.


\subsection{Program output}
\label{ch:impl:out}

The result of execution of \porthos[2] is the \textit{verdict} modelled by the class \texttt{AppVerdict}.
This is a structure that contains the result of analysis and auxiliary information such as collected errors and time of execution (separately for each stage of computing).
The app verdict may be rendered to any format convenient for the user.

