\chapter{The~\texttt{porthos2}:~implementation}
\label{ch:impl}

The main reason for commencing the work on \porthos[2] was the need for processing real-world C programs, which, at first, requires the input language to be extended.
This implies the support not only for new syntactic structures of C language (such as the \texttt{switch} statement or the postfix increment operator \texttt{i++}), but also for its fundamental concepts and features (such as pointer arithmetic or first-order functions), which requires revision of the whole architecture of the tool.
Although far not the entire C language has been supported (that, considering its complexity and numerous pitfalls, goes far beyond current thesis%
\footnote{To ensure that, we have merely to look at existing C compilers, for instance, the open-source \texttt{gcc} compiler, that uses a C parser written in more than 18.5 thousand lines (see \url{https://github.com/gcc-mirror/gcc/blob/master/gcc/c/c-parser.c})}%
), we consider the accomplished work as a step towards this.
%This applies not only to instances that simply constitute the syntactic sugar of C language (such as the \texttt{switch} statement or the prefix increment operator \texttt{++i}), but also to its fundamental concepts and features (such as pointer arithmetic or structures).
%However, the architecture of current version of \porthos{} does not allow to ... as it is ....
% Although and optimisation of the tool so that it is able to process real C programs in perspective.

%In current Chapter we discuss the new architecture of \porthos[2].

% function invocations/calls: inlining with binding
% contexts: for now, no ctxs
% comparing to cprover (https://www.cprover.org/cbmc/doc/manual.pdf, page 45, absatz about 'goto') where "the loop is unwound a given number of times" , we SHOULD have 2 modes of unrolling: 1) number of times, and 2) number of high-level instructions executed
% TODO(code): (https://www.cprover.org/cbmc/doc/manual.pdf, page 45) "The break and continue statements are replaced by equivalent goto statements as described in the ANSI-C standard."

% TODO: arrays: cprover manual page 48


%\section{The architecture of \porthos[1]}
\section{General principles}
\label{ch:impl:principles}

The existing implementation of \porthos[1] does not distinguish the event-based program model from the high-level AST, they both are encoded into single SMT-formula (see classes of package `\texttt{dartagnan.program}' of \porthos tool).
Moreover, the syntax tree was implemented as a mutable data structure, which is being modified at all stages of the program (for instance, see the methods `\texttt{dartagnan.program.Program.compile(...)}' of \porthos{} that recursively compute some properties of the AST and change its state).
We are inclined to consider this architecture as one that is fast to develop, but hard to maintain (since it is difficult to guarantee the correctness of the program) and extend (since adding the support for a new high-level instruction requires changing multiple components of the program, from parser to encoder).
%Moreover, we encounter serious problems when we need to add support for control-flow jumps (as \texttt{continue}, \texttt{break}, \texttt{goto} in C).

% todo: in old porthos the strategy soft: print info about error. new: exception on any detected violation of any invariant

Therefore, while working on the new design of \porthos[2], we decided to clearly separate the high-level intermediate code representation (implemented as a recursive AST structure) from low-level event-based representation (implemented as an event-flow graph).
Such a modular architecture allows to support multiple input languages by parsing them and converting parsed syntax trees to a simplified AST. which, along with all other data-transfer objects (DTO), must be immutable, so that it is possible to guarantee the correctness of the program by controlling its invariants.
The immutability in \porthos[2] is implemented via \texttt{final} fields that are assigned by the immutable-object values (either a primitive type, or another immutable object, or an immutable collection provided by the library Guava by Google%
\footnote{Project repository: \url{https://github.com/google/guava/}}%
).

During the development of \porthos[2] we mainly followed the \textit{KISS~principle}, which can be exhaustively described in 17 Unix Rules of Eric Raymond~\cite{raymond2003art}.% which include the rule of modularity, the rule of clarity, transparency, extensibility, etc.
The following list summarises the main rules we followed during the development of \porthos[2]:

\vspace{0.5em}
\begin{enumerate}[nolistsep]
  \item \textit{Robustness:}
    \begin{enumerate}[label*=\arabic*.]
      \item usage of immutable data structures for all DTOs;
      \item interrupting the work on errors;
      \item modular architecture: each module can be tested independently;
      \item usage of software design patterns if necessary;
    \end{enumerate}
  \item \textit{Transparency:}
    \begin{enumerate}[label*=\arabic*.]
      \item following the principles of simplicity and readability;
      \item clear and informative program output;
    \end{enumerate}
  \item \textit{Efficiency:}
    \begin{enumerate}[label*=\arabic*.]%[leftmargin=1.5em]
      \item keeping the trade-off between execution time and memory usage;
    \end{enumerate}
  \item \textit{Extensibility:}
    \begin{enumerate}[label*=\arabic*.]%[leftmargin=1em]
      \item clear modular architecture.
    \end{enumerate}
\end{enumerate}

The programming language choice for \porthos[2] was also made in favour of \textit{java}, firstly, in order to be able to reuse some parts and concepts of \porthos[1] that is written in java, and secondly, because the authors find the object-oriented (OOP) concepts of java suitable for modelling languages.
Although java does not show best results in performance benchmarks (for example, comparing to C++~\cite{hundt2011loop, oaks2014java}), the performance cornerstone of \porthos[2] (as well as any other SMT-based code analyser) is the phase of solving the SMT-formula, which is left to the third-party SMT-solver called from \porthos[2] via java API.
However, considering the perspective of using \porthos[2] as a static analyser for real-world programs, the memory optimisation problem must also be taken into account during both encoding and solving stages.
It is worth noting that, for the reasons of simplicity, the \porthos[2] is not a concurrent program, however, we believe that, due to its modular architecture, it can be easily parallelised on the level of program modules.


\section{Architecture}
\label{ch:impl:arch}

The general architecture scheme of \porthos[2] is presented in Figure~\ref{fig:arch}.
The program takes as input the program to be analysed and one (the reachability analysis mode) or two (the portability analysis mode) memory models.
The program input is being parsed (Section~\ref{ch:impl:proc:y-parser}) to a program AST called \texttt{Y-tree}%
\footnote{In order to avoid confusion between different internal representations, we prefix the names of elements of each internal representation with a letter. For instance, we picked the letter `Y' to denote the AST code representation as drawing of this letter resembles the tree branching; with letter `X' we prefix elements of the event-flow graph as the events are to be e\textbf{x}ecuted; and with letter `W' we prefix elements of the \textbf{w}eak memory model AST.}%
(Section~\ref{ch:impl:model:ytree}), and the memory model is being parsed (Section~\ref{ch:impl:proc:w-parser}) to another AST called \texttt{W-model} (Section~\ref{ch:impl:model:wmodel}).

Thereafter, the \texttt{Y-tree} is being pre-processed at the pre-compilation stage (Section~\ref{ch:impl:proc:x-compiler:pre}) in order to collect information necessary for the compilation. Then, the \texttt{Y-tree} is being compiled (Section~\ref{ch:impl:proc:x-compiler:comp}) to an \texttt{X-graph} representation (Section~\ref{ch:impl:model:xgraph}), which then undergoes a number of transformations necessary for the encoding to an SMT formula at the post-compilation stage (Section~\ref{ch:impl:proc:x-compiler:post}).
The post-processed \texttt{X-graph} then "fills in" the memory-model \texttt{W-model}, and both are encoded (Section~\ref{ch:impl:proc:z-encoder}) to a \texttt{Z-formula}, which then proceeds to the Z3 solver as an input.

\begin{figure}%[!b]%[H]
  \centering
  % TODO: uncomment after a while
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/my/lucidchart.com/data-flow-vert-300dpi.png}
  \caption{Main components of \porthos[2]}
  \label{fig:arch}
\end{figure}


\subsection{The program input}
\label{ch:impl:input}
%(for instance, the original input language of \porthos{} tool, two variants of syntax of a litmus test used by \tool{herd}, an assembly language for any supported architecture).


\subsection{The Model}
\label{ch:impl:model}
blabla

\subsubsection{Y-tree}
\label{ch:impl:model:ytree}

\subsubsection{X-graph}
\label{ch:impl:model:xgraph}

\subsubsection{W-model}
\label{ch:impl:model:wmodel}

\subsubsection{Z-formula}
\label{ch:impl:model:zformula}

\subsection{The processing units} %Transformation}
\label{ch:impl:proc}

\subsubsection{Y-tree parser}
\label{ch:impl:proc:y-parser}

\subsubsection{W-model parser}
\label{ch:impl:proc:w-parser}

\subsubsection{X-graph compiler}
\label{ch:impl:proc:x-compiler}

\paragraph{Pre-compiler}
\label{ch:impl:proc:x-compiler:pre}

\paragraph{Compiler}
\label{ch:impl:proc:x-compiler:comp}

\paragraph{Post-compiler}
\label{ch:impl:proc:x-compiler:post}

\subsubsection{The Z-formula encoder}
\label{ch:impl:proc:z-encoder}

\subsection{The program output}
\label{ch:impl:out}

%\subsection{Parsing the input}
%\label{ch:impl:input-parser}

Both \porthos{} and \porthos[2] \ use the parser generator ANTLR~\cite{parr2013definitive}, a powerful language processing tool.
The full ANTLR grammar of input language used by previous version of \porthos{} is available at Appendix~\ref{apx:in_grammar_pts}.

% TODO: why we've chosen ANTLR (cite Kvanttt); what kind of parser is ANTLR, why it's good for C and not only for C (unified way to define multiple grammars, large collection, ...) + add references

- Figure~\ref{syntax:in_grammar_pts} represents the informal grammar of the input language processed by \porthos[1] ... %todo: cite \cite{Porthos17}.
- short characteristics of the old grammar, enumerate its features (wrt the Figure)

- DRAWBACKS: %what parts need to be improved:

    -- the semantics of memory operations and method invocations is encoded directly into the grammar.
    Taking into account the complexity of developing the accurate grammar for a Turing-complete language,

    -- in old implementation, the logics of parser was written directly in the grammar.
    Although being fast-to-impelement (1 internal representation less), this is approach has numerous drawbacks s.a.:
    * hard to read grammar (mixing 2 languages in a single file)
    * hard to maintain grammar (no debugging with standard utils, no code analysis in the grammar file)
    * non-extensible (there is no option to just plug-in existing grammar for any language and write a converter from this language's syntax tree to our AST)


    - syntactically only the integers were supported. we:arrays???pointers??enums?structs?
    - no declarations (all shared variables are declared in the init section, local variables are not decalred ever)

    - no arbitrary function calls (need support for the knowledge base after implementing the typisation. cannot be supproted only syntactically)


- Minor drawbacks:

    - restricted sytnax for expressions:

    -- no operator associativity allowed (`1 + 2 * 3` was invalid syntax)

    -- no unary increment/decrement (technically it's hard to implement post-incerment/decrement without interpretation: we don't know when does this expression ends.)
    Example:
    `int* x;
    if (x++ > 0 ) { }`
    % todo: test pre-/post-fix operations //+think how current tool will behave if there's more than one post-operation //and pre-operation

    -- incorrectly implemented statement in old code: sequence of stmts is separated by ';', but the syntax of C requires ';' as the operator that ends each operation (how to say this? see C standard)

    -- litmus-initialisation  stmt did not allow the non-default values. The new syntax allow any type of declaration statement with initialisation

- this means the full compiler engine that resolves the semantics

%The grammar supported by \porthos[2] was extended in order to support expressions valid in C. %TODO: examples, how imenno extended
%Also, the input language of the first version of \porthos{} syntactically distinguished the type of a memory instruction (shared variable assignments were defined with symbol~`\texttt{:=}', and local variable assignments --- with symbol~`$\mathtt{\leftarrow}$'), whereas \porthos[2] determines the semantics of a function invocation during the preprocessing stage of compilation~(see Chapter~\ref{TODO!!!}).

% todo: this is the simplified grammar

%TODO: although the grammar is context-free and fail whith <angle brackets>.... it still works fine. Even gcc uses CF grammar? reference to INRIA's parser and paper on discussing grammars for C

%TODO: say sth about 100500 litmus-tests for kernel

\begin{figure}%[H]
%\begin{multicols}{2}
\begin{lstlisting}[mathescape=true,%
                  caption={Syntax of an input language of \porthos{} version 1},%
                  label={syntax:in_grammar_pts},%
                  %literate={<--}{{$\leftarrow$}}1,%
                  morekeywords={if,then,else,return,while,program,thread}%
                  breaklines=true,%
                  basicstyle=\ttfamily\scriptsize]
<prog> : <init> <thrd>* <assert>
       ;
<thrd> : thread <tid> <inst>
       ;
<inst> : <atom>
       | <inst> ; <inst>
       | while <pred> <inst>
       | if <pred> { <inst> } <inst>
       ;
<atom> : <reg> <-- <expr>
       | <reg> <-- <loc>
       | <loc> := <reg>
       | 'mfence'
       | 'sync'
       | 'lwsync'
       | 'isync'
       ;
<pred> :
       | true
       | false
       | <expr> (and | or) <expr>
       | <expr> ('==' | '!=' | '>' | '>=' | '<' | '>=') <expr>
       ;
<expr> : [0-9]
       | <reg>
       | <expr> ('*' | '+' | '-' | '/' | '%') <expr>
       ;
\end{lstlisting}
%\end{multicols}
\end{figure}


- NOW: we're using the C grammar from the standard

- for now, we just ignore C macro directives, in future it's planned to support partially the preprocessing before parsing

The \porthos[2] uses the C language grammar of proposed in the C11 standard~\cite{jtc2011sc22}, that was extended by litmus test-specific syntax such as initialisation and final-state assertion statements (the original ANTLR grammar can be found in the official ANTLR repository on GitHub~\footnote{The repository containing the collection of ANTLR v4 grammars:\\ \url{https://github.com/antlr/grammars-v4}}).
Current version of \porthos[2] can operate only in the inter-procedural mode, assuming that each function defined in the input file is being executed in a separate thread.
However, the redesigned architecture of \porthos[2] allow to easily support intra-procedural analysis by inlining function calls.

%TODO: say sth about syntax errors handling: still now, what if parser does not accept syntax?

- if we don't support , our parser still parses it, and the error is thrown at the moment of converting syntax tree to the AST (Y-tree).

- So, The language-dependent syntax tree is converted to the AST by the stateless Visitor (e.g., for C11->Ytree conversion is made by 'C2YtreeConverterVisitor') + short structure of this visitor (how?.. need ly?)


%\section{The Y-tree: an AST}
%\label{ch:impl:ytree}

- picture of the Y-hierarchy. everything inherits interface YEntity

- immutable

- AST is untyped (YVariableRef).

- short characteristics with citations from the code (this AST contains very basic language elements according to the C execution model (statements and expressions) )

- minor changes are performed by converting to ytree representation: desugaring the target code, etc. (what else?)


%\section{Model parser}
%\label{ch:impl:model}

TODO


\section{Compiling the Y-tree to the X-graph}
\label{ch:impl:y2x}


\begin{figure}%[!b]%[H]
  \centering
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/my/class-diagrams/XEntity.png}
  \caption{TODO}
  \label{fig:class-diagrams:XEntity}
\end{figure}

\lstinputlisting{inc/XEventVisitor-cleaned.java}


%todo: some words on necessity of contexts and lack of them. How would we implement them

%todo: rename Interpreter -> Compiler.

%note https://en.wikipedia.org/wiki/Semantics_(computer_science)
%Operational semantics loosely corresponds to interpretation,

- hierarchy of Compilers (XCompiler is an stateful abstract machine)

- interface that it provides

- dependencies on other modules (memory-manager, etc.)


\subsection{Pre-compilation}
\label{ch:impl:y2x:precomp}

- collect goto labels (not done yet.)

- determine kind of variables (cannot be done during parsing? don't say this)

- basic typisation

%todo: after all, list which modules (classes, managers) are being initialised during the pre-compilation. I'ts good to have the dependencies graph on moduls (operational semantics:) )

%\subsection{Compilation}
%\label{ch:impl:y2x:compil}

- more low-level code representation (or high-level assembly); abstract assembly language. refer to the %2_wmm.tex

- X-hierarchie


%\subsection{Post-compilation}
%\label{ch:impl:x2y:postcomp}

transformations

- After we acquired the event-based representation, we can perform some modifications/simplifications/optimisations on it (separately, allowing user to manage them)

- converting to SSA form (now: during the encoding. should be: during the post-compilation) (as one of necessary steps before encoding)

- setting up backward edges

- more?

- unrolling: why we cannot encode cyclic structures. reference to the paper (see arXiv version)
% If the analysing program contains a loop, then its control-flow graph represents the cyclic directed graph. Although, in order to be able to encode such a cyclic structure as a boolean formula, this graph needs to be

The original program encoded into the \texttt{XGraph} represents a \textit{flow graph}, a connected cyclic directed graph with single source node \texttt{(ENTRY)} (usually for convenience all leaves are connected to the sink node \texttt{(EXIT)}). The cycles are caused by low-level jump instructions, obtained from non-linear high-level control-flow statements (such as \texttt{while}, \texttt{do-while}, \texttt{for}, etc.). However, the cyclic flow graph cannot be encoded into SMT formula since ...
//TODO:REFERENCE.%TODO



\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[c] (1) [] {$1$};
\node[c] (2) [below left of=1] {$2$};
\node[c] (3) [below right of=1] {$3$};
\node[c] (4) [below of=3] {$4$};
\path[->]
(1) edge [] node {} (2)
(2) edge [bend left=50,dotted] node {} (1)
(1) edge [] node {} (3)
(3) edge [] node {} (4)
(4) edge [bend right=80,dotted] node {} (1)
;
\node[draw=none] (impl) [right=3cm of 3] {$\overset{k = 6}{\longmapsto}$};
;
\node[c] (21) [right=3cm of impl] {$2_1$};
\node[c] (11) [above right=1cm and 1cm of 21]{$1_1$};
\node[c] (31) [below right=1cm and 1cm of 11] {$3_1$};
\node[c] (41) [below of=31] {$4_1$};
\node[c] (12) [below of=21] {$1_2$};
\node[c] (22) [below left=1cm and 1cm of 12] {$2_2$};
\node[c] (32) [below right=1cm and 1cm of 12] {$3_2$};
\node[c] (13) [below of=41] {$1_3$};
\node[c] (14) [below of=22] {$1_4$};
\node[c] (43) [below of=32] {$4_3$};
\node[c] (23) [below of=13] {$2_3$};
\node[c] (33) [below of=13] {$3_3$};
\node[c] (24) [below left=1cm and 1cm of 14] {$2_4$};
\node[c] (34) [below right=1cm and 1cm of 14] {$3_4$};
\node[c] (15) [below right=1cm and -0.3cm of 43] {$1_5$};
\node[c] (44) [below of=33] {$4_4$};
\node[c] (6) [below left=1cm and 1cm of 15] {$6$};
\node[] (11k) [right=3.2cm of 11] {$(k = 1)$};
\node[] (31k) [right=1.7cm of 31] {$(k = 2)$};
\node[] (41k) [right=1.7cm of 41] {$(k = 3)$};
\node[] (13k) [right=1.7cm of 13] {$(k = 4)$};
\node[] (33k) [right=1.7cm of 33] {$(k = 5)$};
\node[] (44k) [right=1.7cm of 44] {$(k = 6)$};
\path[->]
(11) edge [] node {} (21)
(11) edge [] node {} (31)
(31) edge [] node {} (41)
(21) edge [] node {} (12)
(12) edge [bend right=10] node {} (22)
(12) edge [bend left=10] node {} (32)
(41) edge [] node {} (13)
(22) edge [] node {} (14)
(32) edge [] node {} (43)
(13) edge [] node {} (23)
(13) edge [] node {} (33)
(14) edge [bend right=10] node {} (24)
(14) edge [bend left=10] node {} (34)
(43) edge [] node {} (15)
(33) edge [bend right=10] node {} (15)
(33) edge [bend left=10] node {} (44)
(24) edge [bend right=20] node {} (6)
(34) edge [] node {} (6)
(15) edge [] node {} (6)
(44) edge [bend left=20] node {} (6)
;
\end{tikzpicture}
\label{fig:loop-unwind}
\caption{Example of the flow graph from Figure~\ref{fig:merged-loop.....}, unwinded up to the bound $k = 6$}
\end{figure}




%\section{XGraph to ZFormula (SMT) encoder}
%\label{ch:impl:comp:zformula}

- Then, this modified event-representation is being encoded to SMT formula and sent to the solver.



% say something about equals() and hashCode()



%TODO: \section{Optimisations}
