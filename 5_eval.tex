\chapter{Evaluation}
\label{ch:eval}

%TODO: resource trebovaniya

\section{The \texttt{PorthosC} in work}

\subsection{The X-graph compilation}

As a simple example of the compilation process discussed in Section~\ref{ch:impl:proc:x-compiler:compilation}, consider the tiny C test in Figure~\ref{ex:compilation}.
This function does not perform any useful computation, however it contains several syntactic elements (such as prefix increment or loop-breaking statements), which are supported by \porthos[2] comparing to its predecessor.
The control-flow subgraph \xgraph[CF] of the non-unrolled event-flow graph is presented on the right-hand side of the Figure (all graphs generated by \porthos[2] are produced with the help of the open-source library \texttt{Graphviz}~\cite{ellson2001graphviz}).

Each event of the control-flow graph contains the unique number (generated by the \texttt{hashCode} method) in curly brackets below the value, which is necessary for correct displaying the graph.
Write events are denoted with the left-directed arrow `\lstinline{<-}', and the functions \lstinline{load} and \lstinline{store} denote the type of the shared memory event.
The primary transitions that denote unconditional jumps or if-true-transitions are pictured with solid lines, and the alternative transitions that denote if-false-transitions are pictured with dotted lines.
The graph contains a single source event and a single sink event (represented by the grey triangles).

\begin{figure}[!h]
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[language=Java,basicstyle=\ttfamily\small]
void test(int &x, int &y) {
    int r;
    while ((5 + 4/2 * x) 3 
      == 1) {
        if (y > 6)
            continue;
        else if (++y > 7) {
            r = r + 10;
            break;
        }
        r = 11;
    }
    y = x + 1;
}
\end{lstlisting}
\end{minipage}
%
\begin{minipage}{.59\textwidth}
  \includegraphics[width=\textwidth,keepaspectratio]{img/my/graphs/test.png}
\end{minipage}
%
\caption{An example of a C function compiled to the event-flow graph}
\label{ex:compilation}
\end{figure}

The arguments \lstinline{x} and \lstinline{y} of the function are passed by reference, therefore they are treated as global variables.
The local variable declaration `\lstinline{int r;}' produces no events (it is processed by the X-graph pre-compiler that invokes the memory manager to create the new local variable \lstinline{r}).

The first event `\lstinline{load(reg_tmp0 <- x}' loads the value of the global variable \lstinline{x} into the temp register \lstinline{reg_tmp0} in order to satisfy the requirement that all computation must be performed over local variables;
note that each element of the computational tree `\lstinline{eval(eval(eval(5 + eval(eval(4 / 2) * reg_tmp0)) % 3) == 1)}' is represented by a local memory unit (either \texttt{XComputationEvent} or \texttt{XConstant} or \texttt{XRegister}).
The node of this computational event in the control-flow graph has two outgoing edges, the primary edge to the `\lstinline{load(reg_tmp1 <- y}', the first event of the then-branch of the while-loop, and the alternative edge to the \lstinline{nop}-event representing the only event of the else-branch.

As is was discussed in Section~\ref{ch:impl:model:xgraph}, all computation events have no impact to the global state of the concurrent system.
Therefore, the interpreter does not \textit{emit} computational events, but it \textit{creates} them.
This means, when the \texttt{Y2XConverterVisitor} processes the expression tree `\lstinline{(5 + 4/2 * x) 3 == 1}', it calls the method \texttt{createComputationEvent} of the interpreter that only creates the computation event and does not change its state.
However, once the converter meets the global variable \lstinline{x}, it calls the interpreter method \texttt{emitMemoryEvent} to copy its value to a temp register; since it meets the global variables involved to the computation before it ends to process the whole computation expression, the values of all these global variables will be copied to temp registers \textit{before} the computation expression is used by any other event.
Note that if the computation expression has not been used by any other event (for example, as the constant \lstinline{1} in the following C code: `\lstinline{foo(); 1; bar();}'), it is lost from the model (by the term \textit{use} here we mean that the computation event is evaluated as a guard or assigned to another memory unit).


\subsection{The X-graph unrolling}

Once the \xgraph[CF] is constructed, it should be unrolled to an acyclic flow-graph (as it was discussed in Section~\ref{ch:impl:proc:x-unroll}).
The Figure~\ref{ex:unrolling} shows the control-flow subgraph \xgraphU{CF} of the event-flow graph from the previous example (see Figure~\ref{ex:compilation}) unrolled up to bound $k=16$.
The labels of events in the picture are augmented by the event reference-id number (the unrolling depth), separated from the event value by the comma.

Note that the graph does not become a tree after removing the sink node.
Some branches of the graph are merged when the executions have the same event with the same unrolling depth number.
For example, primary transitions of both events `\lstinline{[r <- 11, 10]}' and `\lstinline{[jump(), 10]}' (produced by executions of the first iteration of the \texttt{while} loop) lead to the same event `\lstinline{[load(reg_tmp0 <- x), 11]}' (the first event of the second loop iteration).

%(said before in 4_impl:unrolling)
%Also note that comparing to the unrolling bound description given in Section~\ref{ch:impl:proc:x-unroll}, 
%As the distinction between complete and incomplete sink nodes is not implemented yet, 

\begin{figure}[!h]
\includegraphics[width=\textwidth,keepaspectratio]{img/my/graphs/test_unrolled.png}
\caption{An example of an unrolled event-flow graph represented in Figure~\ref{ex:compilation}}
\label{ex:unrolling}
\end{figure}


\subsection{Reachability analysis}




\subsection{Performance}

Measure time by \porthos[1], \porthos[2]:

- enc-time absolute values

- rate enc-time/solve-time


Compare sizes of formulas


memory usage -- for both encoding and solving




\section{Comparison with HERD}

\subsection{Unique Features}

- (inherited from the first version) : two memory models, smt, ... (?)

- (new) -- ?

- kernel?? TODO: SUPPORT some kernel funcs.


\subsection{Performance}

- perhaps, better performance on a large test