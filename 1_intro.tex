
\chapter{Introduction}
\label{ch:intro}

Most modern computer systems contain large parts that operate concurrently. Though parallelisation of the system can improve its performance drastically, it opens numerous of problems connected to correctness, robustness and reliability, which makes the concurrent program design one of the most difficult problems of programming~\cite{mckenney2017parallel}.
% Most articles, presentations and books on concurrent programming start with words how hard it is.

Traditionally, studies related to concurrent programming concern on more fundamental theoretical questions of designing race-free and lock-free parallel algorithms, asynchronous data structures and synchronisation primitives of a programming language. Unfortunately, when it comes to the real-world concurrent programs, the algorithmic level of abstraction is not enough for guaranteeing their properties of correctness and reliability. The reasons of this fact lie in the code optimisations that both compiler and hardware perform in order to increase performance as much as possible. For instance, Figure~\ref{simple_wmm_x86} provides simple example of reachability of the state `\texttt{(0:EAX=0~/\textbackslash~1:EAX=0)}' on x86 machines (such little examples that illustrate specific behaviour of a WMM are called \textit{litmus tests}).
%reordering of memory access instructions within single process allowed by the x86-TSO weak memory model, which potentially breaks the program logic. 
This state is allowed because in x86 architecture each processor may cache the write to shared memory variable into its local write buffer, so that they do not become visible by other processes immediately. In the example, the write `\texttt{MOV~[x],1}' performed by process \texttt{P0} stores value~\texttt{1} to the shared variable~\texttt{[x]} into the write buffer of process~\texttt{P0}. Meanwhile, the write cache of the process \texttt{P1} may not have updated version of the variable~\texttt{[x]}, neither may have the main memory, so that the read `\texttt{MOV~EBX,[x]}' performed in the process~\texttt{P1} may read the initial value~\texttt{0} even if this variable has been already updated in another thread. These problems have lead to the need for formalisation of semantics of memory operations within different concurrent architectures defined by \textit{weak	memory models (WMM)}.

\begin{figure}
\small \ttfamily
\begin{tabular}{ |l|l| }
\hline
\multicolumn{2}{|l|}{ \{ x=0; y=0; \}} \tabularnewline \hline
P0 & P1 \\ \hline
MOV [x],1 & MOV [y],1 \\
MOV EAX,[y] & MOV EAX,[x] \\
\hline
%\multicolumn{2}{|l|}{locations [x;y;]} \tabularnewline
\multicolumn{2}{|l|}{exists (0:EAX=0~/\textbackslash~1:EAX=0)} \tabularnewline
\hline
\multicolumn{2}{|l|}{x86-TSO: allow} \tabularnewline
\hline

\end{tabular}
\caption{Store buffering (SB): a litmus test on write-read reordering allowed under the x86-TSO weak memory model}
\label{simple_wmm_x86}
\end{figure}

Research of weak memory models firstly aimes to \textit{formalise} develop the formal approach of understanding programs with respect to weak memory models which is systematic, sound and complete. The first (and so far the only) such a framework was presented in 2010~\cite{alglave2010shared}.
%
Secondly, researchers work on extracting the WMMs for hardware architectures from existing implementations of from their specifications, that are written in natural language and thus suffer from ambiguities and incompletenesses. Over last decade the memory models have been extracted for most mainstream multiprocessor architectures, such as x86-TSO (\textit{Total Store Order}) model for x86 architecture formalised in 2009~\cite{owens2009better}, much more relaxed memory model for Power and ARM architectures~\cite{alglave2009semantics,sarkar2011understanding}, for Alpha~\cite{?} and Sparc~\cite{?} memory models were defined in the specification. Moreover, most modern high-level programming languages rely on relaxed memory model. Thus, the memory model for Java that is based on the \textit{happens-before} principle~\cite{lamport1978time} was introduced in J2SE 5.0 in 2004~\cite{manson2005java}; the C++11 standard~\cite{?} has introduced the set of hardware-independent synchronisation fences and atomic operations, whenever the C++17 memory model is based on the relation \textit{strongly happens-before}.
%batty2011mathematizing
Thirdly, important research direction targets the problem of verifying (or at least finding bugs in) existing software systems with respect to WMMs. Perhaps, the most notable work in this field is the project for defining the Linux kernel memory model, which is being actively developing these days~\cite{kernel1}.
%Distributed databases <also need the wmm, see transaction consistency~\cite{bailis2013highly}>

%experiments with kernel?

The first memory model for concurrent systems was formulated by Leslie Lamport back in 1979~\cite{lamport1979make}. This memory model, called the \textit{sequential consistency (SC)}, allows only those executions (interleavings) that produce the same result as if the operations had been executed by single process. This means that the order of operations executed by a process is strictly defined by the program it executes. The SC model does requires the write to a shared variable performed in one process to become visible by all other processes not instantly, but simultaneously. This means each process communicates to the shared memory directly, without local buffering. Another important requirement of SC memory model is that it forbids memory operations reordering within single process (the order is strictly defined by the program).

The SC model is considered to be the strong memory model in the sence that it provides strong guarantees regarding the ordering and caused effect of memory operations. Different relaxations of this model lead to the class of \textit{weak memory models~(WMM)}.
%while preserving consistency
They specify how threads interact through shared memory, when a write becomes visible to other threads and what value a read can return. 
Therefore, WMMs serve as set of guarantees made by designers of execution environment (hardware, programming language, compiler, database, operation system, etc.) to programmers on which behaviours of their concurrent code they may expect. 

Although weak memory studies is rather young research area, there exist frameworks and tools for exploring WMMs and examining simple programs with respect to the them. The state-of-the-art tool is \tool{diy} (for \textit{do it yourself}), developed by the researchers from INRIA institute, France and University of Cambridge, UK.
The \tool{diy}\footnote{Project web page: \url{diy.inria.fr}} is a sofware suite for designing and testing weak memory models. It is firstly released back in 2010, and since that time it remained to be the only tool for testing weak memory models. The \tool{diy} consists of several modules: the litmus tests generators \tool{diy}, the litmus tests concrete executor \tool{litmus} that runs tests on a physical machine while collecting its behaviours, and the weak memory models simulator \tool{herd} that implements reachability analysis for exploring states reachable under specified~WMM.

All the \tool{diy} tools work only with single memory model, however, in real life we face serious engineering problems involving necessity to model more than one execution environment. One of these problems is the \textit{portability} of the program from one hardware architecture to another. A program written in a high-level language is then compiled for different hardware. Even if all the compiler optimisations were disabled (which is rare case nowadays), the behaviour of two compiled versions of the same program may differ due to differences between hardware memory models.
As the result, a program compiled under the platforms $T$ can reach states that are unreachable on the platform $S$, which is a \textit{portability bug} from the source platform $S$ to the target platform $T$~\cite{Porthos17}.

The first tool that performs the WMM-awared portability analysis is \tool{PORTHOS} introduced in April~2017~\cite{Porthos17}. This tool reduces described problem to a bounded reachability problem, which can be solved with help of an SMT-solver. This approach allows to capture symbolically the semantics of analysing program and both weak memory models into single SMT-formula, augmented by the reachability assertion. As most modern SMT-solvers are efficient enough to be able to operate the state space of size millions of variables bounded by millions of constraints~(\cite{malik2009boolean}), the used method can be applicable in solving the real-world problems.
% TODO: search space size: https://courses.cs.washington.edu/courses/csep573/11wi/lectures/ashish-satsolvers.pdf slide 

%In the work~\cite{Porthos17}, the SMT-based approach was defined for analysing the portability of a program from one hardware architechture to another, which is defined as ``an execution that is consistent with the target but inconsistent with the source memory model". Although encoding the control-flow and the data-flow of a program into an SMT-formula seems to be a trivial problem of symbolic execution, encoding of the weak memory model is more tedious. The reason is that some relations of WMMs are defined as mutually-recursive and need to be linearised in order to be encoded into an equivalent logical formula.

%"A portability bug is an execution that is consistent with the target but inconsistent with the source memory model. We capture this alternation with a single existential query. Consistency is specified in terms of acyclicity (and irreflexivity) of relations. Hence, an execution is inconsistent if a derived relation of the (source) memory model contains a cycle (or is not irreflexive)."

Current work aims to rework the proof-of-concept tool \tool{PORTHOS} by extending the input language, which currently represents the minimum subset of C, and revising the general architecture of the tool in order to enhance performance, reliability and mantainability.
%interprocedural analysis
We called the new tool \textbf{the \tool{mousquetaires} framework} as now it not only performs the portability analysis, but can serve as the basis for SMT-solver driven weak memory model analysis.

\section{Thesis structure}
\label{ch:intro:structure}

The Chapter~\ref{ch:wmm} gives more detailed description of the weak memory model-awared analysis and provides description of memory models for some common architectures (x86, ARM and POWER, Sparc, ???). Chapter~...

% TODO: Add intro to the bounded reachability analysis using SAT -- ? 